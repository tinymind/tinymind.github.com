<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 浮生猎趣]]></title>
  <link href="http://blog.lessfun.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.lessfun.com/"/>
  <updated>2014-09-11T15:36:21+08:00</updated>
  <id>http://blog.lessfun.com/</id>
  <author>
    <name><![CDATA[lslin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Invalid Binary, the Binary Is Missing Architectures[arm64] - iTunes Connect的Bug]]></title>
    <link href="http://blog.lessfun.com/blog/2014/09/11/invalid-binary-the-binary-is-missing-architectures-arm64/"/>
    <updated>2014-09-11T14:51:58+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/09/11/invalid-binary-the-binary-is-missing-architectures-arm64</id>
    <content type="html"><![CDATA[<p>从昨天开始，网上iOS开发者哀鸿一片，因为提交App到AppStore的时候，都遇到了这样一个错误：</p>

<blockquote><p>「Today I cannot submit the binary to App Store, with the error &ldquo;Invalid binary, the binary is missing architectures[arm64]&rdquo;.」</p></blockquote>

<p>国内开发者也遇到了同样的问题：<br/>
<a href="http://bbs.lbsyun.baidu.com/redirect.php?tid=12550&amp;goto=lastpost">现在提交的新应用貌似必须支持arm64了</a></p>

<p><a href="http://www.cocoachina.com/ask/questions/show/119687">上传项目到APPstore，遇到的问题</a></p>

<p>公司内部这两天可能刚好不需要提交App，但是这是迟早的事，而项目中大部分引用的库都不支持arm64，未免开始紧张地修改工程编译选项，推动依赖库支持64位架构，沟通、协调、改错，乱成一团蚂蚁。</p>

<p>结果……苹果告诉我们，不好意思，让你们受惊了，这是我们的一个Bug！</p>

<!--more-->


<p>坑爹呢这是！<br/>
<img src="/images/2014/09/keng_die_ne.jpg" alt="ios_tabbar_running" /></p>

<p>苹果开发者论坛里的员工TimT如是说：</p>

<blockquote><p>「Yes, there was a fix recently applied to the server. Everyone should be able to submit 32-bit apps again.」</p></blockquote>

<p><img src="/images/2014/09/invalid_arm64.png" alt="ios_tabbar_running" /> <br/>
<a href="https://devforums.apple.com/message/1039265#1039265">32. Re: Invalid binary, the binary is missing architectures[arm64]</a></p>

<p>居然Sorry也没一句！任你乱如蚂蚁，我自泰然自若。</p>

<p>好了，没啥事了，还不能洗洗睡，继续提交32位App去吧~</p>

<p>PS: 查看.a库或.framework文件支持那些架构的方法如下：</p>

<p>``` bash
; .a
$cd libs
$lipo -info *.a
Architectures in the fat file: libssl.a are: i386 armv7 armv7s</p>

<p>; .framework
$cd xxFramework.framework
$lipo -info xxFramework
Architectures in the fat file: xxFramework are: armv7 armv7s i386</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在UINavigationController中使用UITabBarController，处理Two-stage Rotation错误]]></title>
    <link href="http://blog.lessfun.com/blog/2014/01/15/using-uitabbarcontroller-inside-uinavigationcontroller/"/>
    <updated>2014-01-15T12:12:51+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/01/15/using-uitabbarcontroller-inside-uinavigationcontroller</id>
    <content type="html"><![CDATA[<p>写iOS应用时，经常需要将UITabBarController嵌入到一个根UINavigationController中，如果处理不好，我们会遇到这样的错误：</p>

<pre><code>Two-stage rotation animation is deprecated. This application should use the smoother single-stage animation.
</code></pre>

<p>网上找了一下，StackOverFlow的<a href="http://stackoverflow.com/a/6637554">这个答案</a>说，不应该将UITabBarControllier嵌入到UINavigationController中作为rootViewController，但是，我们的确想要这样做，所以只好寻找其它办法。不过，至少我们可以确定的是，问题出在rootViewController同时包含UITabBarController和UINavigationController。</p>

<!--more-->


<p>几经尝试，最后发现，在设置为<code>window.rootViewController</code>之前，先指定<code>tabBarController.selectedIndex = 0</code>，问题解决。</p>

<p>可以得出，出现上述错误，是因为XCode不知道你需要push哪个子viewController，在加载navigationController的时候，不知道要载入哪一个controller，于是无脑的将tabBarController的viewControllers都动画载入了。</p>

<p>完整代码如下：</p>

<p>``` cpp
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@"Main" bundle:nil];

UINavigationController *navVC = [storyBoard instantiateInitialViewController];
//MainViewController是UITabBarController的子类
MainViewController *rootVC = (MainViewController *)navVC.visibleViewController;
rootVC.delegate = self;
rootVC.selectedIndex = 0;   //需要这样设置

self.window.rootViewController = navVC;

self.window.backgroundColor = [UIColor whiteColor];
[self.window makeKeyAndVisible];
return YES;
</code></pre>

<p>}
```</p>

<p>StoryBoard：</p>

<p><img src="/images/2014/01/ios_tabbar_storyboard.png" alt="ios_tabbar_storyboard" /></p>

<p>运行效果：</p>

<p><img src="/images/2014/01/ios_tabbar_running.png" alt="ios_tabbar_running" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修复iOS中UIScrollView的scrollToTop设置后不生效的问题]]></title>
    <link href="http://blog.lessfun.com/blog/2014/01/13/fix-uiscrollview-scrolltotop-not-working/"/>
    <updated>2014-01-13T15:15:04+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/01/13/fix-uiscrollview-scrolltotop-not-working</id>
    <content type="html"><![CDATA[<p>iOS中的<code>UIScrollView</code>有一个属性<code>scrollToTop</code>，设置为<code>YES</code>之后，点击设备的状态栏(StatusBar)即可将滚动试图的内容滚动到最顶端，在滚动列表很长的时候，这个特性十分有用。</p>

<p>今日在使用这一属性的时候，发现部分情况下，一切正常；但是也有时候，点击状态栏，滚动条没反应！检查了代码，确定已经设置<code>scrollToTop = YES</code>，但是总是会有不起作用的情况。</p>

<p>于是到万能的StackOverflow寻求答案，不失所望，找到了类似的问题：<a href="http://stackoverflow.com/questions/8951357/scroll-uitableview-to-top-when-tapping-top-of-the-screen">scroll UITableView to top when tapping top of the screen</a></p>

<p>答案也解释得很清楚了，如下：</p>

<!--more-->


<p>如果同一个UIViewController中包含了多个UIScrollView，那么只能有一个ScrollView被设置为scrollToTop = YES; 另外的都要设置为NO，否则就会被系统忽略。
比较坑爹的是，该属性默认为YES，在<code>UIScrollView.h</code>中可以看到声明如下：</p>

<p><code>cpp
  @property(nonatomic) BOOL  scrollsToTop;  // default is YES.
</code></p>

<p>所以我们需要显示设置其他的<code>scrollView.scrollToTop = NO</code>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[通过简单的方法适应iOS7中的UIViewController，同时兼容iOS6]]></title>
    <link href="http://blog.lessfun.com/blog/2014/01/10/simple-way-to-adjust-viewcontroller-to-fit-ios7/"/>
    <updated>2014-01-10T15:07:24+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/01/10/simple-way-to-adjust-viewcontroller-to-fit-ios7</id>
    <content type="html"><![CDATA[<h3>设置view从导航栏下方开始布局</h3>

<p>在iOS6及以前的版本中，UIViewController的高度和位置都是从导航栏下方开始的。但是在iOS7中，UIViewController不再提供wantsFullScreenLayout属性，UIViewController创建后默认就是Full Screen的，因此如果带导航栏的应用界面中的部分控件会与导航栏重叠在一起。</p>

<p>我们的应用大都要兼容低于iOS7的版本，所以必须解决这种不兼容的现象。
思路是，还是按照iOS6的布局方式，因为被导航栏覆盖部分界面实在看不出有什么好处。所以，我们需要判断iOS版本，如果是iOS6，一切照旧，如果是iOS7，则设置view从导航栏下方开始布局。</p>

<p>简单的方法，在ViewDidLoad里面增加几句代码即可，如下：</p>

<!--more-->


<p>``` cpp</p>

<p> #define SystemVersionLessThan(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)</p>

<ul>
<li><p>(void)viewDidLoad
{
[super viewDidLoad];</p>

<p>if (!SystemVersionLessThan(@&ldquo;7.0&rdquo;)) {
  self.edgesForExtendedLayout = UIRectEdgeNone;
  self.extendedLayoutIncludesOpaqueBars = NO;
}
}
```</p></li>
</ul>


<p>这样设置之后，可以看到在iOS7中布局跟iOS显示一样了。</p>

<p>如果有很多个UIViewController，只需要新建一个UIViewController的子类，比如<code>MyUIViewController</code>，把上面代码放到MyUIViewController的<code>ViewDidLoad</code>中，然后修改所有的UIViewController为MyUIViewController即可。</p>

<h3>修改iOS7中UITableViewCell的分隔线</h3>

<p>只是还有一个问题，如果添加了UITableView，会发现cell的分隔线短了一小部分，还需设置如下：</p>

<p><code>cpp
  self.tableView.separatorInset = UIEdgeInsetsZero;
</code></p>

<p>修改后的效果如图：
iOS6：<br/>
<img src="/images/2014/01/ios_adjust_ios6.png" alt="ios_adjust_ios6" /></p>

<p>iOS7:<br/>
<img src="/images/2014/01/ios_adjust_ios7.png" alt="ios_adjust_ios6" /></p>

<p>iOS7表格分隔线：<br/>
<img src="/images/2014/01/ios_adjust_ios7_tableviewcell.png" alt="ios_adjust_ios6" /></p>

<p>搞定！</p>

<h3>去掉iOS6中导航栏的阴影</h3>

<p>iOS6的UINavigationBar默认加了一层阴影，而iOS7中则默认没有，我们可以通过下面的代码去掉iOS6的导航栏阴影：</p>

<p>``` cpp
  if (!SystemVersionLessThan(@&ldquo;6.0&rdquo;)) {</p>

<pre><code>  [[UINavigationBar appearance] setShadowImage:[[UIImage alloc] init]];
</code></pre>

<p>  }
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中检测UIScrollView滚动动画是否结束]]></title>
    <link href="http://blog.lessfun.com/blog/2013/12/06/detect-uiscrollview-did-end-scrolling-animate/"/>
    <updated>2013-12-06T00:34:00+08:00</updated>
    <id>http://blog.lessfun.com/blog/2013/12/06/detect-uiscrollview-did-end-scrolling-animate</id>
    <content type="html"><![CDATA[<p>在iOS中使用UITableView的时候，有时候需要检测UITableView的滚动动画是否结束，但是很遗憾，iOS没有直接提供这样的API。
先看一下现有的几个方法是怎样的：</p>

<p><code>cpp
- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate;
</code>
这个方法表示手指离开了scrollview，第二个参数用于判断滚动速度是否慢慢下降。</p>

<p><code>cpp
- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView;      // called when scroll view grinds to a halt
</code>
这个方法看上去挺像我们要找的：停止减速。但是，从注释看，“嘎然而止”的时候才会被调用，很明显，我们要的是“自然停止”时被调的方法。</p>

<p><code>cpp
- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView; // called when setContentOffset scrollRectVisible:animated: finishes. not called if not animating
</code>
这个是指scrollview停止滚动动画，嗯，这下是我们想要的了吧！</p>

<p>抱歉，不是！！！
试验一下就会发现，无论怎么滚动怎么停止，这个方法都不会被调！处分用代码的方式调用了<code>setContentOffset scrollRectVisible:animated: finishes</code>，但是，我们手指触发试图滚动是不会调该方法的……</p>

<p>一堆似是而非的方法绕得头晕啊……</p>

<h3>解决方法</h3>

<!--more-->


<p>我们自己主动去调<code>scrollViewDidEndScrollingAnimation</code>。</p>

<p>原理：在<code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</code>内，创建一个异步调用，等待0.1秒后调<code>scrollViewDidEndScrollingAnimation</code>。由于<code>scrollViewDidScroll</code>会不断被调用，再次触发时取消上一次的异步请求。等到不再滚动时，最后一次的请求不会被取消，最终会跑到<code>scrollViewDidScroll</code>，然后，添加想要在滚动停止时调用的代码即可。</p>

<p>代码如下：</p>

<p>``` cpp
&ndash;(void)scrollViewDidScroll:(UIScrollView *)sender
{</p>

<pre><code>[NSObject cancelPreviousPerformRequestsWithTarget:self];
[self performSelector:@selector(scrollViewDidEndScrollingAnimation:) withObject:nil afterDelay:0.1]; 
</code></pre>

<p>}</p>

<p>&ndash;(void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView
{</p>

<pre><code>[NSObject cancelPreviousPerformRequestsWithTarget:self];
//这里添加你的逻辑，比如，触发上拉加载更多
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
</feed>
