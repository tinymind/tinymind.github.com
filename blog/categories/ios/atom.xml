<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 浮生猎趣]]></title>
  <link href="http://blog.lessfun.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.lessfun.com/"/>
  <updated>2015-04-01T14:57:11+08:00</updated>
  <id>http://blog.lessfun.com/</id>
  <author>
    <name><![CDATA[lslin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[UITableView性能优化，提升列表滚动的流畅性]]></title>
    <link href="http://blog.lessfun.com/blog/2015/04/01/uitableview-performence-improve/"/>
    <updated>2015-04-01T12:13:46+08:00</updated>
    <id>http://blog.lessfun.com/blog/2015/04/01/uitableview-performence-improve</id>
    <content type="html"><![CDATA[<p>UITableView是iOS开发中最常用也很实用并且最容易出现性能问题的的一个控件，本文列出了一些性能优化点，用于提高列表滚动的流畅性。</p>

<!--more-->


<h2>1. 重用</h2>

<p>当TableView需要显示一个Cell时，会先从已创建的Cell中找一个可以重用的，然后展现到屏幕。一般情况下，可以被重用的Cell都滚到了屏幕区域外。如果慢慢地拖动TableView，就可以看到Cell不断地被重用（通过断点可以看到Cell的init或awakeFromNib没有被调用）。但是如果快速滚动，还是可能会看到Cell被创建。</p>

<h3>1.1 已经在StoryBoard的TableView中定义Cell的ProtoType</h3>

<p>则指定其ReuseIdentify，在delegate返回Cell的时候，调用：
``` c</p>

<pre><code> [tableView dequeueReusableCellWithIdentifier:kCellID];
</code></pre>

<p>```</p>

<h3>1.2 Cell是从单独的xib加载</h3>

<p>则需要先注册：
``` c</p>

<pre><code> [tableView registerNib:[UINib nibWithNibName:kCellID bundle:nil] forCellReuseIdentifier:kCellID];
</code></pre>

<p>```</p>

<h3>1.3 Cell的ProtoType个数尽可能少，因为Cell的种类越多，TableView创建的Cell个数就越多，并且是成倍增长。</h3>

<h2>2. 缓存</h2>

<p>缓存基本上可以解决大部分性能问题。TableView需要知道Cell的高度，才能对Cell进行布局；需要知道所有的Cell的高度，才能知道TableView本身的高度，所以，每次调用reloadData，都需要计算所有Cell的高度。我们要尽量减小高度计算的复杂度。</p>

<h3>2.1 缓存Cell的高度</h3>

<h4>2.1.1 高度固定、类型单一的Cell</h4>

<p>在创建TableView的时候，直接设置其rowHeight属性。</p>

<h4>2.1.2 对于高度固定、类型多样的Cell</h4>

<p>实现代理方法，根据Cell的类型返回不同的高度：
<code>c
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
</code></p>

<h4>2.1.3 对于高度不固定的Cell</h4>

<p><img src="/images/2015/04/tableview_dynamic_cell.png" alt="dynamic uitableviewcell" /></p>

<p>由于需要动态计算高度，所以运算量必然会增大，但是还是存在优化的空间。常见的优化方式是，把cellHeight作为data的一个属性缓存起来，对于每一个data对应的每一个cell，就只需要计算一次高度。示例代码：
``` c</p>

<pre><code>@interface ContentInfo : NSObject

@property(nonatomic, assign) DetailInfo *detail;
@property(nonatomic, strong) CGFloat cellHeight;

- (CGFloat)calcHeight;

@end

- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    ContentInfo *info = _dataSource[index];
    if (info.cellHeight &lt;= 0.1) {
        info.cellHeight = [info calcHeight];
    }
    return info.cellHeight;
}
</code></pre>

<p>```</p>

<p>当然，这样的方式，还是把运算量放到了TableView的代理方法内，其实也可以在创建ContentInfo本身的时候，就调用它的calcHeight方法，在代理方法里就可以可以直接返回info.cellHeight了。但也要结合实际情况进行取舍，因为有时候，有了数据源，但不一定需要展示TableView，提前计算高度反而会浪费时间。</p>

<h3>2.2 缓存Cell的资源</h3>

<p>比如每一个Cell都需要用到的UIImage，UIFont，NSDateFormatter或者任何在绘制时需要的对象，推荐使用类层级的初始化方法中执行分配，并将其存储为静态变量。</p>

<h2>3. 创建</h2>

<h3>3.1 去掉AutoLayout</h3>

<p>如果发现通过StoryBoard+xib+AutoLayout创建Cell时性能满足不了需求，可以考虑去掉AutoLayout。</p>

<h3>3.2 代码创建Cell</h3>

<p>如果不用AutoLayout还是有问题，可以考虑通过代码创建Cell的Views。</p>

<h3>3.3 自绘</h3>

<p>如果使用代码创建还是解决不了问题，那就只能靠自绘了，重载Cell的drawRect方法即可。</p>

<h2>4. 渲染</h2>

<h3>4.1 减少子View的个数和层级</h3>

<p>子View的层级越深，渲染到屏幕上所需要的计算量就越大。</p>

<h3>4.2 减少子View的透明图层</h3>

<p>对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容。</p>

<h3>4.3 避免CAlayer特效。</h3>

<p>给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：
``` c</p>

<pre><code>view.layer.shadowColor = color.CGColor;
view.layer.shadowOffset = offset;
view.layer.shadowOpacity = 1;
view.layer.shadowRadius = radius;
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MarkText - iOS 上支持语法高亮、HTML预览、文件导出的Markdown文本编辑器]]></title>
    <link href="http://blog.lessfun.com/blog/2014/12/10/marktext-a-markdown-text-editor-for-ios/"/>
    <updated>2014-12-10T21:29:06+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/12/10/marktext-a-markdown-text-editor-for-ios</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/app/marktext/marktext_appicon.png" width="120" height="120" title="&lsquo;MarkText App&rsquo; &lsquo;A Markdown Text Editor&rsquo;" ></p>

<p>MarkText是iPhone上的Markdown文本编辑器。支持实时语法高亮、带CSS的HTML预览、文件导出为HTML/PNG/PDF, 分享到Evernote，Dropbox或 Email。</p>

<p>当前版本：1.0.1<br/>
更新时间：2014.01.14</p>

<h2>iPhone 屏幕截图</h2>

<div style="margin-top:30px;font-size:16px;line-height:20px;background:rgb(78,81,85);border-radius:4px;padding:4px;">
<div style="margin: 0 14px; max-height: 640px; min-height: 320px; overflow-x: auto; overflow-y: hidden; padding-bottom: 16px; white-space: nowrap;"><img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/marktext/marktext_screenshot_1.png" alt="1"> <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/marktext/marktext_screenshot_2.png" alt="2"> <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/marktext/marktext_screenshot_3.png" alt="3"> <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/marktext/marktext_screenshot_4.png" alt="4"> <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/marktext/marktext_screenshot_5.png" alt="5"></div>
</div>


<h2>下载</h2>

<p><a href="https://itunes.apple.com/cn/app/marktext-markdown-text-editor/id948768793?mt=8"><img src="/images/app/appstore_available.png" alt="从AppStore下载" /></a></p>

<h2>应用介绍</h2>

<!--more-->


<p>MarkText是iPhone上的一款Markdown文本编辑器.</p>

<h3>编辑 &amp; 分享</h3>

<p>通过MarkText，你可以导入或创建markdown格式的文本文件，支持实时语法高亮显示。编辑完后，支持将markdown的纯文本转换为HTML、PNG或PDF文件，通过iTunes导出到电脑，或者分享到Evernote、Dropbox或Email。</p>

<h3>光标增强</h3>

<p>辅助工具条可以让你很方便地点击按钮插入Tabs、标题、列表、代码块，或者超链接。左右滑动工具条可以迅速移动光标；双指选择可以快速选择文本。</p>

<h3>HTML预览</h3>

<p>HTML预览支持CSS样式，语法高亮支持的特性：常规Markdown、MultiMarkdown、脚注、图片、表格和代码块。</p>

<h2>版本1.0.1 新特性</h2>

<ul>
<li>Bug 修复；</li>
<li>字数统计;</li>
<li>全文搜索。</li>
</ul>


<h2>版本1.0.0 特性</h2>

<ul>
<li>创建、编辑markdown格式的文本；</li>
<li>实时语法高亮；</li>
<li>带CSS样式的HTML预览；</li>
<li>修改主题配色；</li>
<li>从iTunes导入文稿；</li>
<li>导出文稿为HTML、PNG和PDF格式的文件；</li>
<li>分享内容到Evernote、Dropbox和Email；</li>
<li>光标增强：滑动输入工具栏，快速移动光标；</li>
<li>支持的文件后缀类型：md、mmd、markdown、markdn、mdown、mkdn、markd、txt、text。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014年在Apple Store申请iOS个人开发者账号详细流程]]></title>
    <link href="http://blog.lessfun.com/blog/2014/12/03/ios-developer-program-tutorial-2014/"/>
    <updated>2014-12-03T19:20:56+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/12/03/ios-developer-program-tutorial-2014</id>
    <content type="html"><![CDATA[<p><img src="/images/2014/12/idp_intro.png" alt="idp intro" /></p>

<!--more-->


<p>想要在AppStore上发布个人App从来都不是一件简单的事，光是申请开发者账号就可以折腾好久了。这是加入个人开发者计划，申请iOS开发者账号的最新教程，2014年版，供参考。什么时候，苹果才能为开发者考虑一下，减少各种繁琐的流程呢？</p>

<h2>前期准备</h2>

<ul>
<li>需要有一张支持美元支付的信用卡。</li>
</ul>


<h2>注册Apple ID</h2>

<ol>
<li><p>访问<a href="https://developer.apple.com/cn/programs/ios/">https://developer.apple.com/cn/programs/ios/</a> ，点击<code>立即注册</code>。<br/>
<img src="/images/2014/12/idp_register.png" alt="apple register" /></p></li>
<li><p>按照提示，选择注册类型：公司或个人。这里以「个人」为例，点击继续。<br/>
<img src="/images/2014/12/idp_register_continue.png" alt="register continue" /></p></li>
<li><p>注册或创建Apple ID。如果已有，可以继续使用。我选了新建。<br/>
<img src="/images/2014/12/idp_create_apple_id.png" alt="create apple id" /></p></li>
<li><p>按照要求填写接口。需要注意的地方：FirstName 和 LastName 要是自己的名字拼音，由于涉及到审核、支付、收款等操作，不要乱填。另外，中英文的姓名顺序一直都可以把人绕晕，总之，我在 FirstName 填了名字拼音，在 LastName 填姓氏拼音。<br/>
<img src="/images/2014/12/idp_fill_apple_id.png" alt="fill apple id" /></p></li>
<li><p>设置安全问题答案，找回密码需要。</p></li>
<li>验证邮箱，之后就可以使用新的AppleID了，如果在上面填错了资料，可以登录修改，比如姓名。<br/>
<img src="/images/2014/12/idp_verify_email.png" alt="verify email" /></li>
</ol>


<h2>填写开发者信息</h2>

<ol>
<li><p>在协议这里打钩，点击<code>Agree</code>。<br/>
<img src="/images/2014/12/idp_develop_agreement.png" alt="develop agreement" /></p></li>
<li><p>完善个人的一些信息。<br/>
<img src="/images/2014/12/idp_self_info.png" alt="self info" /></p></li>
<li><p>至此，Apple ID创建完成。<br/>
<img src="/images/2014/12/idp_register_finished.png" alt="register finished" /></p></li>
</ol>


<h2>加入开发者计划</h2>

<ol>
<li><p>这时候已有新的Apple ID，再次打开<a href="https://developer.apple.com/programs/ios">https://developer.apple.com/programs/ios</a> ，正式加入$99/年的个人开发者计划。<br/>
<img src="/images/2014/12/idp_enroll_now.png" alt="enroll now" /></p></li>
<li><p>选择刚刚创建的Apple ID：<br/>
<img src="/images/2014/12/idp_select_apple_id.png" alt="select apple id" /></p></li>
<li><p>提示选择注册类型，个人或公司。这里选择个人。<br/>
<img src="/images/2014/12/idp_select_individual.png" alt="select individual" /></p></li>
<li><p>输入账单地址等信息，这里需要与信用卡账单显示的地址完全一致，中英文各输入一遍，注意输入手机号时，区号填<code>86</code>。<br/>
<img src="/images/2014/12/idp_credit_card_address.png" alt="credit card address" /></p></li>
<li><p>选择开发者计划类型。<br/>
<img src="/images/2014/12/idp_select_program.png" alt="select program" /></p></li>
<li><p>Review，检查没问题后，提交。</p></li>
<li>继续同意协议。<br/>
<img src="/images/2014/12/idp_program_license.png" alt="program license" /></li>
</ol>


<h2>提交订单、付款</h2>

<ol>
<li><p>终于到了付款这一步骤了，点击<code>Buy now</code>。<br/>
<img src="/images/2014/12/idp_buy_now.png" alt="buy now" /></p></li>
<li><p>再次要求登录Apple ID。<br/>
<img src="/images/2014/12/idp_login_again.png" alt="login again" /></p></li>
<li><p>输入信用卡信息进行付款。<br/>
<img src="/images/2014/12/idp_credit_card_info.png" alt="credit card info" /></p></li>
<li><p>提交订单。<br/>
<img src="/images/2014/12/idp_commit_order.png" alt="commit order" /></p></li>
<li><p>付款完成提示，等待苹果发送激活的邮件吧。</p></li>
</ol>


<p><img src="/images/2014/12/idp_order_tips.png" alt="order tips" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[到底什么时候才需要在ObjC的Block中使用weakSelf/strongSelf]]></title>
    <link href="http://blog.lessfun.com/blog/2014/11/22/when-should-use-weakself-and-strongself-in-objc-block/"/>
    <updated>2014-11-22T15:59:18+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/11/22/when-should-use-weakself-and-strongself-in-objc-block</id>
    <content type="html"><![CDATA[<p>Objective C 的 <code>Block</code> 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(<code>retain cycle</code>)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 &lsquo;self->theVar'，'self&rsquo; 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>

<!--more-->


<h3>解决 retain circle</h3>

<p>Apple 官方的建议是，传进 Block 之前，把 &lsquo;self&rsquo; 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。</p>

<p>示例代码：</p>

<p>``` m</p>

<p><strong>weak </strong>typeof__(self) weakSelf = self;</p>

<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
[weakSelf doSomething];
</code></pre>

<p>});</p>

<p>```</p>

<p>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</p>

<p>``` m</p>

<p><strong>weak </strong>typeof__(self) weakSelf = self;</p>

<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
[weakSelf doSomething];
[weakSelf doOtherThing];
</code></pre>

<p>});</p>

<p>```</p>

<p>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</p>

<p>``` m</p>

<p><strong>weak </strong>typeof__(self) weakSelf = self;</p>

<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
__strong __typeof(self) strongSelf = weakSelf;
[strongSelf doSomething];
[strongSelf doOtherThing];
</code></pre>

<p>});</p>

<p>```</p>

<p><code>__strong</code> 确保在 Block 内，strongSelf 不会被释放。</p>

<h3>总结</h3>

<ul>
<li>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</li>
<li>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</li>
</ul>


<h3>参考</h3>

<ul>
<li><a href="http://dhoerl.wordpress.com/2013/04/23/i-finally-figured-out-weakself-and-strongself/">I finally figured out weakSelf and strongSelf</a></li>
<li><a href="http://stackoverflow.com/questions/21113963/is-the-weakself-strongself-dance-really-necessary-when-referencing-self-inside-a?rq=1">Is the weakSelf/strongSelf dance really necessary when referencing self inside a non-retained completion called from a UIViewController?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 6.1 iPhone Simulator 8.1 Keyboard Issue：键盘无法显示，设置inputAccessoryView崩溃]]></title>
    <link href="http://blog.lessfun.com/blog/2014/10/24/xcode-6-dot-1-iphone-simulator-8-dot-1-keyboard-issue/"/>
    <updated>2014-10-24T14:42:51+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/10/24/xcode-6-dot-1-iphone-simulator-8-dot-1-keyboard-issue</id>
    <content type="html"><![CDATA[<p>随着iPhone 6 &amp; Plus的发布，苹果也陆续更新了XCode和开发模拟器，目前最新的Xcode版本是6.1，内置的Simulator的iOS版本是8.1。也许你兴致冲冲迫不及待地一下子升级到了最新版的开发环境，那么可能会遇到一些键盘上的问题：无法弹出键盘，或者弹出键盘后会莫名其妙地崩溃。</p>

<p>当然，不能怪你，你的项目在iOS7.1上是运行地好好的。只能怪苹果没有推出一个完美无Bug的开发工具。</p>

<!--more-->


<h2>1. 在XCode 6，iOS 8.1模拟器无法弹出键盘</h2>

<p>解决方法很简单，在Simulator的系统菜单中，取消勾选：</p>

<p><code>Hardware</code> &ndash;> <code>Keyboard</code> &ndash;> <code>Connect Hardware Keyboard</code>。</p>

<p>取消选中之后，键盘可以正常弹出，但是，无法使用硬件的键盘输入了，自己慢慢用鼠标点击模拟器里的键盘吧……</p>

<h2>2. 弹出键盘后会莫名其妙地崩溃</h2>

<p>也许你键盘能正常显示了，但是一显示就崩溃，在堆栈中有这样的字样：</p>

<p>``` m</p>

<pre><code>*** First throw call stack:
(
    0   CoreFoundation                      0x02101df6 __exceptionPreprocess + 182
    1   libobjc.A.dylib                     0x01d8ba97 objc_exception_throw + 44
    2   CoreFoundation                      0x02101d1d +[NSException raise:format:] + 141
    3   UIKit                               0x008cff9c -[UIViewController _addChildViewController:performHierarchyCheck:notifyWillMove:] + 210
    4   UIKit                               0x00f4b44d -[UIInputWindowController changeToInputViewSet:] + 576
    5   UIKit                               0x00f4c1be __43-[UIInputWindowController setInputViewSet:]_block_invoke + 103
    6   UIKit                               0x007f73bf +[UIView(Animation) performWithoutAnimation:] + 82
    7   UIKit                               0x00f4bf9c -[UIInputWindowController setInputViewSet:] + 374
    8   UIKit                               0x00ce9101 __64-[UIPeripheralHost(UIKitInternal) setInputViews:animationStyle:]_block_invoke1459 + 43
    9   UIKit                               0x00f473af -[UIInputWindowController performOperations:withAnimationStyle:] + 56

......
}
</code></pre>

<p>```</p>

<p>以上崩溃也只在XCode 6，iOS 8出现，在iOS 7一切正常。</p>

<p>原因可能是你设置了<code>UITextField</code>或<code>UITextView</code>的<code>inputView</code>或<code>inputAccessoryView</code>为customView，比如这样：</p>

<p>``` m</p>

<pre><code>//在Xib或Storyboard中创建了一个自定义View
@property (strong, nonatomic) IBOutlet UIView *switchKeyboardBar;

...

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.textView.inputAccessoryView = self.switchKeyboardBar;
}
</code></pre>

<p>```</p>

<p>上述代码在iOS 8中是必定Crash的，因为<code>UITextView.inputAccessoryView</code>不能是其他View的子View。而上面的<code>switchKeyboardBar</code>先被添加到了当前<code>UIViewController</code>的<code>View</code>中，再被设置到<code>inputAccessoryView</code>，就会导致崩溃。</p>

<h3>2.1 解决方法</h3>

<p>不从Xib创建自定义View，而是在代码中手动创建，并且不添加到别的View中。</p>

<p>如下：</p>

<p>``` m</p>

<pre><code>//注意这里没有 IBOutlet
@property (strong, nonatomic) UIView *switchKeyboardBar;

- (UIView *)switchKeyboardBar
{
    if (!_switchKeyboardBar) {
        _switchKeyboardBar = [[UIView alloc] initWithFrame:CGRectMake(0, 0, CGRectGetWidth(self.view.frame), 40)];

        //add other subviews
        ...
    }
    return _switchKeyboardBar;
}

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.textView.inputAccessoryView = self.switchKeyboardBar;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
</feed>
