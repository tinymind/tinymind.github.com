<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 浮生猎趣]]></title>
  <link href="http://blog.lessfun.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.lessfun.com/"/>
  <updated>2015-12-25T18:39:22+08:00</updated>
  <id>http://blog.lessfun.com/</id>
  <author>
    <name><![CDATA[lslin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[非越狱 iOS 在后台截屏、录制屏幕的相关实现]]></title>
    <link href="http://blog.lessfun.com/blog/2015/12/25/ios-record-screen-in-background/"/>
    <updated>2015-12-25T16:54:31+08:00</updated>
    <id>http://blog.lessfun.com/blog/2015/12/25/ios-record-screen-in-background</id>
    <content type="html"><![CDATA[<h2>需求</h2>

<p>先简单介绍一下标题的含义。也许你看到<code>iOS</code>、<code>截屏</code>，觉得这有什么好长篇大论的，小菜一碟而已。可能你忽略了<code>后台</code>这个关键词。</p>

<p>这里的关键就在于怎么在 App 切换到后台之后，仍然能够持续截取用户屏幕内容。解决了这点，剩下的就是把图片合成视频，有必要的话再加入声音。</p>

<p>另外，需要说明的是，实现后台截屏只能使用私有 API，而苹果是不允许这类 App 上架的，就算你用了一些技巧（比如动态加载私有 API 以绕过 App Store 的审核）而上架，假以时日苹果也会发现并且下架处理。<a href="http://stackoverflow.com/questions/11090184/how-does-the-ios-app-display-recorder-record-the-screen-without-using-private-ap">Display Recorder</a> 就是这么做并且被下架的，所以现在它发到越狱市场了。</p>

<h2>作用</h2>

<p>在 iOS 上录制全局屏幕，保存成一个视频，这么一个小众需求到底有什么作用？虽然一般用户都不会用到，不过它还是有点用的：</p>

<ul>
<li>录制 App 使用的视频教程（而不是图片+文字、图片+文字、图片+文字）；</li>
<li>如果 App 有个在某些用户机器上必现的 Bug，可以让他把操作记录下来，发给开发者（这样码农们就没办法再推脱：“在我这里是好的！肯定是你的打开方式不对！”）；</li>
<li>如果你是游戏大神，玩得一手好手游，还可以把你在游戏中的神操作保存下来供日后回味（或者分享出去让小白们膜拜）。</li>
</ul>


<!--more-->


<h2>实现</h2>

<p>iOS 的系统封闭，API 变化无常，所以并没有一个可以全版本 iOS 系统通用的后台截屏方法。下面所列的方法都因系统版本而异，前提都是非越狱。</p>

<h3>1. _UICreateScreenUIImage (&lt; iOS 6)</h3>

<p><a href="http://iphonedevwiki.net/index.php/UIImage#UICreateScreenUIImage">_UICreateScreenUIImage</a> 是 UIImage 的一个私有方法，在<strong> iOS 6</strong>以前可以用于后台调用截屏，方法如下：</p>

<p>``` objc
OBJC_EXTERN UIImage *_UICreateScreenUIImage(void);</p>

<ul>
<li>(void)takeScreenshot {
  UIImage *screenImage = _UICreateScreenUIImage();
  // &hellip;
}
```</li>
</ul>


<p>但是，在 iOS 6 以后，这个方法不允许在 App 切到后台的时候调用了，会在调试控制台输出不能调用的错误提示。</p>

<h3>2. CARenderServerRenderDisplay (&lt; iOS 7)</h3>

<p><a href="https://github.com/coolstar/RecordMyScreen">RecordMyScreen</a> 用的就是这个方法，不过实测在 iOS 7以上，只能截到黑色的空白图片。网上说 RecordMyScreen 就是 Display Recorder 的开源版本。</p>

<p>其中涉及到后台截屏的代码如下：</p>

<p>``` objc</p>

<pre><code>IOSurfaceLock(_surface, 0, nil);
// Take currently displayed image from the LCD
CARenderServerRenderDisplay(0, CFSTR("LCD"), _surface, 0, 0);
// Unlock the surface
IOSurfaceUnlock(_surface, 0, 0);

// Make a raw memory copy of the surface
void *baseAddr = IOSurfaceGetBaseAddress(_surface);
int totalBytes = _bytesPerRow * _height;
NSMutableData *rawDataObj = [NSMutableData dataWithBytes:baseAddr length:totalBytes];
// ...
</code></pre>

<p>```</p>

<p>但是，经过测试，在iOS 7和iOS 8上，这个方法没办法正确截屏，只能得到黑色的图片。而且，虽说 RecordMyScreen 是一个开源项目，但实际上它并不是一份完整可用的代码，开源到中途，作者发现有人在窃取他的项目源码，于是停止了开源。虽然如此，该项目中对于音视频的编码、合成部分的处理都是很值得参考的。</p>

<h3>3. createScreenIOSurface(&lt; iOS 7?)</h3>

<p><a href="https://github.com/kishikawakatsumi/ScreenRecorder">ScreenRecorder</a> 用了这个方法，但是实际上这个项目没办法在后台运行。</p>

<p>``` objc</p>

<p>@interface UIWindow (ScreenRecorder)
+ (CFTypeRef)createScreenIOSurface;
@end</p>

<ul>
<li><p>(void)screenShot {
  CFTypeRef surface = [UIWindow createScreenIOSurface];
  backingData = surface;</p>

<p>  NSDictionary <em>pixelBufferAttributes = @{(NSString </em>)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)};
  status = CVPixelBufferCreateWithIOSurface(NULL, surface, (__bridge CFDictionaryRef)(pixelBufferAttributes), &amp;buffer);
  // &hellip;
}
```</p></li>
</ul>


<h3>4. 终极方法 IOSurface (&lt; iOS 9)</h3>

<p>好吧，前面提到的几种方法在 iOS 7 以上版本都没啥卵用。现在说的这个方法是可以在 iOS 7 和 iOS 8 上使用的，只是 iOS 9 禁用了该方法。</p>

<p>与 RecordMyScreen 类似，还是基于 IOSurface 私有库，只是调用的方法不太一样：</p>

<p>``` objc
&ndash; (UIImage *)screenshot() {</p>

<pre><code>IOMobileFramebufferConnection connect;
kern_return_t result;
</code></pre>

<p>CoreSurfaceBufferRef screenSurface = NULL;</p>

<pre><code>io_service_t framebufferService = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("AppleH1CLCD"));
</code></pre>

<p>if(!framebufferService)</p>

<pre><code>    framebufferService = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("AppleM2CLCD"));
</code></pre>

<p>if(!framebufferService)</p>

<pre><code>    framebufferService = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("AppleCLCD"));
</code></pre>

<p>result = IOMobileFramebufferOpen(framebufferService, mach_task_self(), 0, &amp;connect);
result = IOMobileFramebufferGetLayerDefaultSurface(connect, 0, &amp;screenSurface);</p>

<pre><code>uint32_t aseed;
IOSurfaceLock((IOSurfaceRef)screenSurface, 0x00000001, &amp;aseed);
size_t width = IOSurfaceGetWidth((IOSurfaceRef)screenSurface);

size_t height = IOSurfaceGetHeight((IOSurfaceRef)screenSurface);
CFMutableDictionaryRef dict;
</code></pre>

<p>size_t pitch = width<em>4, size = width</em>height*4;</p>

<pre><code>int bPE=4;

char pixelFormat[4] = {'A','R','G','B'};
dict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
CFDictionarySetValue(dict, kIOSurfaceIsGlobal, kCFBooleanTrue);
CFDictionarySetValue(dict, kIOSurfaceBytesPerRow, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;pitch));
CFDictionarySetValue(dict, kIOSurfaceBytesPerElement, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;bPE));
CFDictionarySetValue(dict, kIOSurfaceWidth, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;width));
CFDictionarySetValue(dict, kIOSurfaceHeight, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;height));
CFDictionarySetValue(dict, kIOSurfacePixelFormat, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, pixelFormat));
CFDictionarySetValue(dict, kIOSurfaceAllocSize, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;size));

IOSurfaceRef destSurf = IOSurfaceCreate(dict);
IOSurfaceAcceleratorRef outAcc;
IOSurfaceAcceleratorCreate(NULL, 0, &amp;outAcc);

IOSurfaceAcceleratorTransferSurface(outAcc, (IOSurfaceRef)screenSurface, destSurf, dict, NULL);
IOSurfaceUnlock((IOSurfaceRef)screenSurface, kIOSurfaceLockReadOnly, &amp;aseed);
</code></pre>

<p>CFRelease(outAcc);</p>

<pre><code>CGDataProviderRef provider =  CGDataProviderCreateWithData(NULL,  IOSurfaceGetBaseAddress(destSurf), (width * height * 4), NULL);

CGImageRef cgImage = CGImageCreate(width, height, 8,
</code></pre>

<p>8*4, IOSurfaceGetBytesPerRow(destSurf),
 CGColorSpaceCreateDeviceRGB(), kCGImageAlphaNoneSkipFirst |kCGBitmapByteOrder32Little, provider, NULL, YES, kCGRenderingIntentDefault);</p>

<pre><code>UIImage *image = [UIImage imageWithCGImage:cgImage];
return image;
</code></pre>

<p>}
```</p>

<p>见：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/21870667/iomobileframebuffergetlayerdefaultsurface-does-not-work-on-ios7-retina">IOMobileFramebufferGetLayerDefaultSurface does not work on ios7 retina</a></li>
<li><a href="http://stackoverflow.com/questions/32239969/iomobileframebuffergetlayerdefaultsurface-not-working-on-ios-9">IOMobileFramebufferGetLayerDefaultSurface not working on iOS 9</a></li>
</ul>


<h2>合成</h2>

<p>在 App 后台得到截图之后怎么处理成视频呢？其实在 RecordMyScreen 中有完整的代码可以参考，只是它里面截屏的方法需要替换为本文提到的<code>第四种</code>实现，不赘述。</p>

<h2>注意</h2>

<ol>
<li>需要修改 App 的 plist 文件，使其能在后台运行。</li>
<li>需要打开设备的 Access Touch 功能，否则对于 OpenGL 实现的游戏 App，会黑屏。</li>
<li>iPad Retina 屏幕像素过大，处理起来很吃力，需要减小生成的图片大小。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIViewController Push & Pop 的那些坑]]></title>
    <link href="http://blog.lessfun.com/blog/2015/09/09/uiviewcontroller-push-pop-trap/"/>
    <updated>2015-09-09T18:37:32+08:00</updated>
    <id>http://blog.lessfun.com/blog/2015/09/09/uiviewcontroller-push-pop-trap</id>
    <content type="html"><![CDATA[<p>iOS开发中，UIViewController是最常用的一个类，在Push和Pop的过程中也会经常出现一些UI卡死、App闪退的问题，本文总结了开发中遇到的一些坑。</p>

<p>大部分视图控制器切换导致的问题，根本原因都是使用了动画，因为执行动画需要时间，在动画未完成的时候又进行另一个切换动画，容易产生异常，假如在 Push 和 Pop 的过程不使用动画，世界会清静很多。所以本文只讨论使用了动画的视图切换。也就是使用以下方式的 Push 和 Pop：</p>

<p>``` objc</p>

<pre><code>[self.navigationController pushViewController:controller animated:YES];
[self.navigationController popViewControllerAnimated:YES];
</code></pre>

<p>```</p>

<!--more-->


<h2>1. 连续 Push</h2>

<p>连续两次 Push 不同的 ViewController 是没问题的，比如这样：</p>

<p>``` objc
&ndash; (void)onPush: {</p>

<pre><code>[self.navigationController pushViewController:vc1 animated:YES];
[self.navigationController pushViewController:vc2 animated:YES];
</code></pre>

<p>}
```</p>

<p>但是，如果不小心连续 Push 了同一个 ViewController，并且 animated 为 YES，则会 Crash：<code>Pushing the same view controller instance more than once is not supported</code>。</p>

<p>这种情况很有可能发生，特别是界面上触发切换的入口不止一处，并且各个入口的点击没有互斥的话，用两根手指同时点击屏幕就会同时触发两个入口的切换了。多点触碰导致的同时 Push，基本上是防不胜防，当界面元素很复杂的时候，特别容易出现这个问题，而指望从用户交互的角度上避免这个问题是不可能的，测试美眉以暴力测试、胡乱点击而著称，防得了用户防不住测试。</p>

<p>所以我们需要从根本上解决这个问题：当一个 Push 动画还没完成的时候，不允许再 Push 别的 ViewController。这样处理是没有问题的，因为连续带动画地 Push 多个 ViewController 肯定不是开发和产品的意愿，就算有这种需求，也可以通过禁用动画的方式来解决。</p>

<h3>1.1 解决方案</h3>

<p>继承 UINavigationController 并重载 pushViewController 方法。</p>

<ol>
<li>如果是动画 Push，并且属性 <code>isSwitching == YES</code>，则忽略这次 Push。</li>
<li>否则，设置 <code>isSwitching = YES</code> 再继续切换。</li>
<li>等到动画切换完毕，需要再把 <code>isSwitching</code> 改为 NO。</li>
</ol>


<p>``` objc</p>

<p>@interface MYNavigationController () &lt;UINavigationControllerDelegate, UIGestureRecognizerDelegate></p>

<p>@property (assign, nonatomic) BOOL isSwitching;</p>

<p>@end</p>

<p>@implementation MYNavigationController</p>

<p>// 重载 push 方法
&ndash; (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated {</p>

<pre><code>if (animated) {
    if (self.isSwitching) {
        return; // 1. 如果是动画，并且正在切换，直接忽略
    }
   self.isSwitching = YES; // 2. 否则修改状态
}

[super pushViewController:viewController animated:animated];
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; UINavigationControllerDelegate</h1>

<ul>
<li>(void)navigationController:(UINavigationController <em>)navigationController didShowViewController:(UIViewController </em>)viewController animated:(BOOL)animated {
  self.isSwitching = NO; // 3. 还原状态
}</li>
</ul>


<p>```</p>

<h2>2. 连续 Pop</h2>

<p>连续 Pop ，可能会导致两种情况。</p>

<h3>2.1 self 被释放</h3>

<p>例如，下面的代码，执行到第二句的时候，self 已经被释放了。</p>

<p>``` objc</p>

<pre><code>[self.navigationController popViewControllerAnimated:YES]; // self 被 release
[self.navigationController popViewControllerAnimated:YES]; // 继续访问 self 导致异常
</code></pre>

<p>```</p>

<h3>2.2 界面异常、崩溃</h3>

<p>假如你避开了上面那种调用，换成了这样：</p>

<p>``` objc</p>

<pre><code>[[AppDelegate sharedObject].navigationController popViewControllerAnimated:YES]; 
[[AppDelegate sharedObject].navigationController popViewControllerAnimated:YES]; 
</code></pre>

<p>```</p>

<p>由于访问的是全局的 AppDelegate，自然避免了调用者被释放的问题，但是，连续两次动画 Pop，在iOS 7.X 系统会导致界面混乱、卡死、莫名其妙的崩溃（iOS 8 貌似不存在类似的问题）。比如，下面这个崩溃的堆栈：</p>

<p>```
{&ldquo;bundleID&rdquo;:&ldquo;com.enterprise.kiwi&rdquo;,&ldquo;app_name&rdquo;:&ldquo;kiwi&rdquo;,&ldquo;bug_type&rdquo;:&ldquo;109&rdquo;,&ldquo;name&rdquo;:&ldquo;kiwi&rdquo;,&ldquo;os_version&rdquo;:&ldquo;iPhone OS 7.1.1 (11D201)&rdquo;,&ldquo;version&rdquo;:&ldquo;1190 (3.1.0)&rdquo;}
Incident Identifier: FE85E864-393C-417D-9EA0-B4324BEEDA2F
CrashReporter Key:   a54805586b9487c324ff5f42f4ac93dabbe9f23e
Hardware Model:      iPhone6,1
Process:             kiwi [1074]
Path:                /var/mobile/Applications/D81CE836-3F88-481C-AA5A-21DA530234E0/kiwi.app/kiwi
Identifier:          com.yy.enterprise.kiwi
Version:             1190 (3.1.0)
Code Type:           ARM-64 (Native)
Parent Process:      launchd [1]</p>

<p>Date/Time:           2015-09-08 15:44:57.327 +0800
OS Version:          iOS 7.1.1 (11D201)
Report Version:      104</p>

<p>Exception Type:  EXC_CRASH (SIGSEGV)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Triggered by Thread:  1</p>

<p>Thread 0:
0   libobjc.A.dylib                 0x00000001993781dc objc_msgSend + 28
1   UIKit                           0x000000018feacf14 &ndash;[UIResponder(Internal) <em>canBecomeFirstResponder] + 20
2   UIKit                           0x000000018feacba0 &ndash;[UIResponder becomeFirstResponder] + 240
3   UIKit                           0x000000018feacfa0 &ndash;[UIView(Hierarchy) becomeFirstResponder] + 120
4   UIKit                           0x000000018ff320f8 &ndash;[UITextField becomeFirstResponder] + 64
5   UIKit                           0x000000018ffe4800 &ndash;[UITextInteractionAssistant(UITextInteractionAssistant_Internal) setFirstResponderIfNecessary] + 208
6   UIKit                           0x000000018ffe3f84 &ndash;[UITextInteractionAssistant(UITextInteractionAssistant_Internal) oneFingerTap:] + 1792
7   UIKit                           0x000000018ffcac60 </em>UIGestureRecognizerSendActions + 212
8   UIKit                           0x000000018fe5929c &ndash;[UIGestureRecognizer <em>updateGestureWithEvent:buttonEvent:] + 376
9   UIKit                           0x000000019025803c </em><strong>UIGestureRecognizerUpdate_block_invoke + 56
10  UIKit                           0x000000018fe1a258 <em>UIGestureRecognizerRemoveObjectsFromArrayAndApplyBlocks + 284
11  UIKit                           0x000000018fe18b34 </em>UIGestureRecognizerUpdate + 208
12  UIKit                           0x000000018fe57b1c &ndash;[UIWindow <em>sendGesturesForEvent:] + 1008
13  UIKit                           0x000000018fe5722c &ndash;[UIWindow sendEvent:] + 824
14  UIKit                           0x000000018fe28b64 &ndash;[UIApplication sendEvent:] + 252
15  UIKit                           0x000000018fe26c54 </em>UIApplicationHandleEventQueue + 8496
16  CoreFoundation                  0x000000018ce1f640 </strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION<strong> + 20
17  CoreFoundation                  0x000000018ce1e99c </strong>CFRunLoopDoSources0 + 252
18  CoreFoundation                  0x000000018ce1cc34 __CFRunLoopRun + 628
19  CoreFoundation                  0x000000018cd5dc1c CFRunLoopRunSpecific + 448
20  GraphicsServices                0x0000000192a45c08 GSEventRunModal + 164
21  UIKit                           0x000000018fe8efd8 UIApplicationMain + 1152
22  kiwi                            0x000000010026a2b8 main (main.mm:26)
23  libdyld.dylib                   0x000000019995ba9c start + 0</p>

<p>Thread 1 Crashed:
0   libsystem_kernel.dylib          0x0000000199a3daa8 kevent64 + 8
1   libdispatch.dylib               0x0000000199941998 _dispatch_mgr_thread + 48
```</p>

<p>从崩溃记录完全看不出原因，十分坑爹。</p>

<h3>2.3 解决方案</h3>

<ul>
<li>方案一：第一次 Pop 不使用动画。</li>
<li>方案二：统一管理 Pop 的调用，如果当前正在 Pop，则下一次 Pop 先入栈；等到 Pop 执行完再执行下一次 Pop。</li>
</ul>


<h2>3. Push 的过程中立即 Pop</h2>

<p>Push 的过程中调用 Pop，会导致界面卡死，表现为：不响应任何点击、手势操作，但是不会崩溃。这也是在 iOS7 中出现的问题，iOS 8 之后不存在。</p>

<h3>3.1 解决方案</h3>

<p>同 1.1，重载 Pop 方法：</p>

<ol>
<li>Pop 的时候先判断是否在切换中；</li>
<li>如果正在切换，则 Pop 的命令先保存到队列；</li>
<li>切换动画执行完毕，判断是否需要处理 Pop 的队列。</li>
</ol>


<p>``` objc</p>

<h1>pragma mark &ndash; UINavigationController</h1>

<ul>
<li><p>(NSArray <em>)popToViewController:(UIViewController </em>)viewController animated:(BOOL)animated {
  if (!self.isSwitching) {
      return [super popToViewController:viewController animated:animated];
  } else {
      [self enqueuePopViewController:viewController animate:animated];
      return nil;
  }
}</p></li>
<li><p>(UIViewController *)popViewControllerAnimated:(BOOL)animated {
  if (!self.isSwitching) {
      return [super popViewControllerAnimated:animated];
  } else {
      [self enqueuePopViewController:nil animate:animated];
      return nil;
  }
}</p></li>
</ul>


<h1>pragma mark &ndash; UINavigationControllerDelegate</h1>

<ul>
<li><p>(void)navigationController:(UINavigationController <em>)navigationController didShowViewController:(UIViewController </em>)viewController animated:(BOOL)animated {
  self.isSwitching = NO;</p>

<p>  // 显示完毕之后判断是否需要Pop
  if (self.popVCAnimateQueue.count) {
      PopVCInfo *info = [self.popVCAnimateQueue firstObject];
      [self.popVCAnimateQueue removeObjectAtIndex:0];
      if (info.controller) {
          [self.navigationController popToViewController:info.controller animated:info.animate];
      } else {
          [self.navigationController popViewControllerAnimated:info.animate];
      }
  }
}</p></li>
</ul>


<p>```</p>

<h2>4. Push 的过程中手势滑动返回</h2>

<p>手势滑动返回本质上调用的还是 Pop，所以，同上。</p>

<p>不过，还可以更根本地禁止用户进行这样的操作，也就是在切换过程中禁止滑动返回手势。</p>

<p>``` objc</p>

<h1>pragma mark &ndash; UINavigationController</h1>

<p>// Hijack the push method to disable the gesture
&ndash; (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated {</p>

<pre><code>self.interactivePopGestureRecognizer.enabled = NO;

[super pushViewController:viewController animated:animated];
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; UINavigationControllerDelegate</h1>

<ul>
<li><p>(void)navigationController:(UINavigationController <em>)navigationController didShowViewController:(UIViewController </em>)viewController animated:(BOOL)animated {
  self.isSwitching = NO;</p>

<p>  self.interactivePopGestureRecognizer.enabled = YES;</p>

<p>  // 显示完毕之后判断是否需要Pop
  if (self.popVCAnimateQueue.count) {
      PopVCInfo *info = [self.popVCAnimateQueue firstObject];
      [self.popVCAnimateQueue removeObjectAtIndex:0];
      if (info.controller) {
          [self.navigationController popToViewController:info.controller animated:info.animate];
      } else {
          [self.navigationController popViewControllerAnimated:info.animate];
      }
  }
}</p></li>
</ul>


<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[密码计算器，保护您iPhone里的隐私文件]]></title>
    <link href="http://blog.lessfun.com/blog/2015/04/07/passcalc-protect-your-privacy-in-iphone/"/>
    <updated>2015-04-07T16:48:09+08:00</updated>
    <id>http://blog.lessfun.com/blog/2015/04/07/passcalc-protect-your-privacy-in-iphone</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/app/passcalc/passcalc_appicon.png" width="120" height="120" title="&lsquo;PassCalc App&rsquo; &lsquo;PassCalc App&rsquo;" ></p>

<p>密码计算器是iPhone上的一款私密文件管理器，通过在计算器上输入密码来访问您的私人文件，可以完美地保护您的照片、视频、日记、联系人等私人隐私文件。</p>

<p>当前版本：1.0.1<br/>
更新时间：2015.05.06</p>

<h2>iPhone 屏幕截图</h2>

<div style="margin-top:30px;font-size:16px;line-height:20px;background:rgb(78,81,85);border-radius:4px;padding:4px;">
<div style="margin: 0 14px; max-height: 640px; min-height: 320px; overflow-x: auto; overflow-y: hidden; padding-bottom: 16px; white-space: nowrap;"><img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/passcalc/passcalc_screenshot_1.png" alt="1"> <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/passcalc/passcalc_screenshot_2.png" alt="2"> <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/passcalc/passcalc_screenshot_3.png" alt="3"> <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/passcalc/passcalc_screenshot_4.png" alt="4"> <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/passcalc/passcalc_screenshot_5.png" alt="5"></div>
</div>


<h2>下载</h2>

<p><a href="https://itunes.apple.com/cn/app/id980936769?mt=8"><img src="/images/app/appstore_available.png" alt="从AppStore下载" /></a></p>

<!-- more -->


<h2>应用介绍</h2>

<p>密码计算器是iPhone上的一款私密文件管理器。那么多年以来，你一定保存了一些私密的照片、视频、笔记或联系人在手机里，并且不想被你身边的人看到。密码计算器可以完美地实现你的需求，保护你的隐私。表面上这是一款计算器，但是可以输入密码来访问你的私人文件。</p>

<h3>安全性</h3>

<ul>
<li>使用RSA，AES加密技术来存储照片、笔记、视频和联系人。</li>
<li>即使手机被盗，被破解，别人也无法打开加密的文件，妈妈再也不用担心你的艳照门啦。</li>
</ul>


<h3>文件管理器</h3>

<ul>
<li>使用WiFi、USB与电脑进行文件上传、下载。</li>
<li>从相机或相册导入照片、视频。</li>
<li>通过邮件、微信来分享文字、图片，支持发送Gif动态表情。</li>
<li>支持视频格式：mov，m4v，mp4，mpv，3gp。</li>
<li>支持图片格式：jpg，png，gif，bmp。</li>
<li>支持笔记扩展名：txt，text，md，markdown，markd，markdn，mdown，mkd，mkdn。</li>
</ul>


<h3>私密笔记</h3>

<ul>
<li>语法高亮。</li>
<li>通过电子邮件、微信分享。</li>
</ul>


<h3>私密文档</h3>

<ul>
<li>支持的文档类型：doc, ppt, xls, docx, pptx, xlsx, key, numbers, pages, pdf, rtf；</li>
<li>可导入、导出、分享文档。</li>
</ul>


<h3>私密联系人</h3>

<ul>
<li>无限制添加联系人。</li>
<li>给联系人添加备注。</li>
<li>快速拨号，发送短信，发送电子邮件。</li>
</ul>


<h3>浏览器</h3>

<ul>
<li>全功能浏览器，无障碍地访问你想看的网站，并且不留下蛛丝马迹。</li>
<li>保存你常用的书签，方便你下次再次访问。</li>
<li>一键下载网页上的所有图像，保存到图像可以在相册中找到。</li>
<li>离线浏览网页，保存完整网页内容为PDF。</li>
</ul>


<h3>更多</h3>

<ul>
<li>功能完善的数学计算器。</li>
<li>应用程序切换到后台时，自动显示计算器界面。</li>
</ul>


<h3>1.0.1更新信息</h3>

<ul>
<li>新增文档类型，支持：doc, ppt, xls, docx, pptx, xlsx, key, numbers, pages, pdf, rtf；</li>
<li>离线浏览网页，保存完整网页内容为PDF；</li>
<li>调用第三方App打开文件；</li>
<li>处理来自第三方的文件；</li>
<li>支持 iOS 8 Today Extension；</li>
<li>Bug 修复。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UITableView性能优化，提升列表滚动的流畅性]]></title>
    <link href="http://blog.lessfun.com/blog/2015/04/01/uitableview-performence-improve/"/>
    <updated>2015-04-01T12:13:46+08:00</updated>
    <id>http://blog.lessfun.com/blog/2015/04/01/uitableview-performence-improve</id>
    <content type="html"><![CDATA[<p>UITableView是iOS开发中最常用也很实用并且最容易出现性能问题的的一个控件，本文列出了一些性能优化点，用于提高列表滚动的流畅性。</p>

<!--more-->


<h2>1. 重用</h2>

<p>当TableView需要显示一个Cell时，会先从已创建的Cell中找一个可以重用的，然后展现到屏幕。一般情况下，可以被重用的Cell都滚到了屏幕区域外。如果慢慢地拖动TableView，就可以看到Cell不断地被重用（通过断点可以看到Cell的init或awakeFromNib没有被调用）。但是如果快速滚动，还是可能会看到Cell被创建。</p>

<h3>1.1 已经在StoryBoard的TableView中定义Cell的ProtoType</h3>

<p>则指定其ReuseIdentify，在delegate返回Cell的时候，调用：
``` c</p>

<pre><code> [tableView dequeueReusableCellWithIdentifier:kCellID];
</code></pre>

<p>```</p>

<h3>1.2 Cell是从单独的xib加载</h3>

<p>则需要先注册：
``` c</p>

<pre><code> [tableView registerNib:[UINib nibWithNibName:kCellID bundle:nil] forCellReuseIdentifier:kCellID];
</code></pre>

<p>```</p>

<h3>1.3 Cell的ProtoType个数尽可能少，因为Cell的种类越多，TableView创建的Cell个数就越多，并且是成倍增长。</h3>

<h2>2. 缓存</h2>

<p>缓存基本上可以解决大部分性能问题。TableView需要知道Cell的高度，才能对Cell进行布局；需要知道所有的Cell的高度，才能知道TableView本身的高度，所以，每次调用reloadData，都需要计算所有Cell的高度。我们要尽量减小高度计算的复杂度。</p>

<h3>2.1 缓存Cell的高度</h3>

<h4>2.1.1 高度固定、类型单一的Cell</h4>

<p>在创建TableView的时候，直接设置其rowHeight属性。</p>

<h4>2.1.2 对于高度固定、类型多样的Cell</h4>

<p>实现代理方法，根据Cell的类型返回不同的高度：
<code>c
- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath
</code></p>

<h4>2.1.3 对于高度不固定的Cell</h4>

<p><img src="/images/2015/04/tableview_dynamic_cell.png" alt="dynamic uitableviewcell" /></p>

<p>由于需要动态计算高度，所以运算量必然会增大，但是还是存在优化的空间。常见的优化方式是，把cellHeight作为data的一个属性缓存起来，对于每一个data对应的每一个cell，就只需要计算一次高度。示例代码：
``` c</p>

<pre><code>@interface ContentInfo : NSObject

@property(nonatomic, assign) DetailInfo *detail;
@property(nonatomic, strong) CGFloat cellHeight;

- (CGFloat)calcHeight;

@end

- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {
    ContentInfo *info = _dataSource[index];
    if (info.cellHeight &lt;= 0.1) {
        info.cellHeight = [info calcHeight];
    }
    return info.cellHeight;
}
</code></pre>

<p>```</p>

<p>当然，这样的方式，还是把运算量放到了TableView的代理方法内，其实也可以在创建ContentInfo本身的时候，就调用它的calcHeight方法，在代理方法里就可以可以直接返回info.cellHeight了。但也要结合实际情况进行取舍，因为有时候，有了数据源，但不一定需要展示TableView，提前计算高度反而会浪费时间。</p>

<h3>2.2 缓存Cell的资源</h3>

<p>比如每一个Cell都需要用到的UIImage，UIFont，NSDateFormatter或者任何在绘制时需要的对象，推荐使用类层级的初始化方法中执行分配，并将其存储为静态变量。</p>

<h2>3. 创建</h2>

<h3>3.1 去掉AutoLayout</h3>

<p>如果发现通过StoryBoard+xib+AutoLayout创建Cell时性能满足不了需求，可以考虑去掉AutoLayout。</p>

<h3>3.2 代码创建Cell</h3>

<p>如果不用AutoLayout还是有问题，可以考虑通过代码创建Cell的Views。</p>

<h3>3.3 自绘</h3>

<p>如果使用代码创建还是解决不了问题，那就只能靠自绘了，重载Cell的drawRect方法即可。</p>

<h2>4. 渲染</h2>

<h3>4.1 减少子View的个数和层级</h3>

<p>子View的层级越深，渲染到屏幕上所需要的计算量就越大。</p>

<h3>4.2 减少子View的透明图层</h3>

<p>对于不透明的View，设置opaque为YES，这样在绘制该View时，就不需要考虑被View覆盖的其他内容。</p>

<h3>4.3 避免CAlayer特效。</h3>

<p>给Cell中View加阴影会引起性能问题，如下面代码会导致滚动时有明显的卡顿：
``` c</p>

<pre><code>view.layer.shadowColor = color.CGColor;
view.layer.shadowOffset = offset;
view.layer.shadowOpacity = 1;
view.layer.shadowRadius = radius;
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MarkText - iOS 上支持语法高亮、HTML预览、文件导出的Markdown文本编辑器]]></title>
    <link href="http://blog.lessfun.com/blog/2014/12/10/marktext-a-markdown-text-editor-for-ios/"/>
    <updated>2014-12-10T21:29:06+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/12/10/marktext-a-markdown-text-editor-for-ios</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/app/marktext/marktext_appicon.png" width="120" height="120" title="&lsquo;MarkText App&rsquo; &lsquo;A Markdown Text Editor&rsquo;" ></p>

<p>MarkText是iPhone上的Markdown文本编辑器。支持iCloud同步，实时语法高亮、带CSS的HTML预览、文件导出为HTML/PNG/PDF, 分享到Evernote，Dropbox或Email。</p>

<p>当前版本：1.0.3<br/>
更新时间：2015.05.06</p>

<h2>iPhone 屏幕截图</h2>

<div style="margin-top:30px;font-size:16px;line-height:20px;background:rgb(78,81,85);border-radius:4px;padding:4px;">
<div style="margin: 0 14px; max-height: 640px; min-height: 320px; overflow-x: auto; overflow-y: hidden; padding-bottom: 16px; white-space: nowrap;">
  <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/marktext/marktext_screenshot_1.png" alt="1">
  <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/marktext/marktext_screenshot_2.png" alt="2">
  <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/marktext/marktext_screenshot_3.png" alt="3">
  <img style="border:2px solid white;margin:5px;box-shadow:0 0 5px rgba(220,220,220,0.5);width:320px;" src="http://blog.lessfun.com/images/app/marktext/marktext_screenshot_4.png" alt="4">
</div>
</div>


<h2>下载</h2>

<p><a href="https://itunes.apple.com/cn/app/marktext-markdown-text-editor/id948768793?mt=8"><img src="/images/app/appstore_available.png" alt="从AppStore下载" /></a></p>

<h2>应用介绍</h2>

<!--more-->


<p>MarkText是iPhone与iPad上的一款Markdown文本编辑器，支持iCloud同步，实时语法高亮，能转换为HTML、PNG或PDF文件。通过Email发送格式化的markdown内容，或者调用第三方App打开转换后的文件。</p>

<h3>导入 &amp; 导出</h3>

<p>通过iTunes导入markdown文本文件，或通过MarkText创建，编辑时支持实时语法高亮显示。编辑完成之后，可以通过iTunes导出到电脑，或者转换为HTML、PNG、PDF文件并发送到Evernote、Dropbox、Email等第三方App。</p>

<h3>光标增强</h3>

<p>辅助工具条可以让你很方便地点击按钮插入Tabs、标题、列表、代码块，或者超链接。左右滑动工具条可以迅速移动光标；双指选择可以快速选择文本。</p>

<h3>HTML预览</h3>

<p>HTML预览支持CSS样式，语法高亮支持的特性：常规Markdown、MultiMarkdown、脚注、图片、表格和代码块。</p>

<h3>iCloud同步：</h3>

<p>通过iCloud，在所有设备自动同步存储所有文件。</p>

<h2>版本1.0.3 新特性</h2>

<ul>
<li>支持通过邮件发送HTML内容；</li>
<li>修复：HTML预览的加粗、斜体；</li>
<li>修复：关闭iCloud同步后无法新建文档；</li>
<li>修复：iOS 8下可能出现的光标抖动；</li>
<li>修复：在空行无法点击快捷输入。</li>
</ul>


<h2>主要功能</h2>

<ul>
<li>创建、编辑markdown格式的文本；</li>
<li>实时语法高亮；</li>
<li>带CSS样式的HTML预览；</li>
<li>修改主题配色；</li>
<li>通过iTunes导入、导出文件；</li>
<li>转换为HTML、PNG或PDF格式；</li>
<li>分享到Evernote、Dropbox或Email等App；</li>
<li>光标增强：滑动输入工具栏，快速移动光标；</li>
<li>支持的文件后缀：md、mmd、markdown、markdn、mdown、mkdn、markd、txt、text；</li>
<li>全文搜索；</li>
<li>字数统计;</li>
<li>支持正则的查找替换;</li>
<li>iCloud同步。</li>
</ul>

]]></content>
  </entry>
  
</feed>
