<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 浮生猎趣]]></title>
  <link href="http://blog.lessfun.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.lessfun.com/"/>
  <updated>2014-09-24T16:36:27+08:00</updated>
  <id>http://blog.lessfun.com/</id>
  <author>
    <name><![CDATA[lslin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[App适配iOS8遇到的兼容问题：键盘方向与StatusBar方向不一致，阻止锁屏失效，OpenGL崩溃]]></title>
    <link href="http://blog.lessfun.com/blog/2014/09/24/ios8-issue-keyboard-orientation-and-idletimerdisabled-not-working/"/>
    <updated>2014-09-24T13:59:29+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/09/24/ios8-issue-keyboard-orientation-and-idletimerdisabled-not-working</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/2014/09/lessfun_ios8_adapt.png" title="&lsquo;ios8 adapt&rsquo; &lsquo;ios8 adapt&rsquo;" >
苹果正式发布iOS8系统，到现在安装覆盖率已达48%，而iOS7的安装率是49%。所以，各位开发者又有得忙了，把所有的App都升级并适配到iOS8系统可不是一件轻松的事。</p>

<p>下面罗列一下我在适配iOS8过程中遇到的兼容问题——而同样的代码在iOS6/7是完全没问题的。</p>

<!--more-->


<h2>1. 键盘弹出方向与StatusBar方向不一致</h2>

<p>在App中，第一个ViewController是只支持竖屏方向(Portrait)的，切换到第二个页面，默认也是Portrait，但用户可以点击按钮切换为横屏(Landscape)。</p>

<p>所以，我把App-Info.plist只选中了<code>Portrait</code>一项，并且在<code>Root ViewController</code>重载了以下方法：</p>

<p>``` c</p>

<pre><code>- (BOOL)shouldAutorotate
{
    return NO;
}

- (NSUInteger)supportedInterfaceOrientations
{
    return UIInterfaceOrientationMaskPortrait;
}

- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation
{
    return UIInterfaceOrientationPortrait;
}
</code></pre>

<p>```</p>

<p>然后在需要切换到横屏的时候，调用以下代码：</p>

<p>``` c</p>

<ul>
<li>(void)onFullScreenButtonTouchUpInside:(id)sender
{
  [self adjustViewFrameToFullScreen];
  [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight animated:NO];
}</li>
</ul>


<p>```</p>

<p>由于在iOS6、7中，键盘方向是跟随状态栏方向的，所以一切表现正常，横屏下，无论设备方向怎样，键盘都是横着弹出。</p>

<p>但是，在iOS8中，键盘却随着设备方向弹出了。换言之，<strong>即使Interface Orientation为Landscape，但Device Orientation为Portrait，键盘就会以Portrait的方向弹出</strong>。<br/>
如下图：</p>

<p><img class="center" src="/images/2014/09/lessfun_ios8_adapt_keyboard.png" title="&lsquo;ios8 adapt keyboard&rsquo; &lsquo;ios8 adapt keyboard&rsquo;" ></p>

<h3>1.1 解决方法</h3>

<p>我想要的是键盘不管设备方向，只关注状态栏方向，也就是StatusBarOrientation。由于iOS8新出不久，在网上没找到解决方案。后来我一同事发现手动更改设备方向可以解决这一问题：</p>

<p>``` c</p>

<ul>
<li>(void)onFullScreenButtonTouchUpInside:(id)sender
{
  [self adjustViewFrameToFullScreen];
  [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight animated:NO];
  //改设备方向
  if (IsIOS8) {
      [[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIDeviceOrientationLandscapeLeft] forKey:@&ldquo;orientation&rdquo;];
  }
}</li>
</ul>


<p>```</p>

<h2>2. 禁用屏幕自动锁定失效</h2>

<p>本来，防止屏幕锁定只需一句代码：</p>

<p>``` c</p>

<pre><code>[[UIApplication sharedApplication] setIdleTimerDisabled:YES];
</code></pre>

<p>```</p>

<p>但是，在iOS8中，偶尔会失效。测试人员发现了这个问题是在弹出键盘点击发送后必现，而原因不明。因为键盘出现与隐藏，理论上不应该影响这个<code>idleTimerDisabled</code>的属性。暂且认为是iOS8的Bug吧。</p>

<h3>2.1 解决方法</h3>

<p>在键盘收起的时候，重设<code>IdleTimerDisabled</code>。</p>

<p>``` c</p>

<pre><code>- (void)onKeyboardDidHide:(NSNotification *)notification
{
    if (IsIOS8) {
        [[UIApplication sharedApplication] setIdleTimerDisabled:YES];
    }
}
</code></pre>

<p>```</p>

<h2>3. OpenGL ES渲染时崩溃</h2>

<p>在iOS中使用OpenGL ES渲染，切换到后台时需要停止渲染，否则会引起崩溃。见这里：<a href="https://developer.apple.com/library/ios/qa/qa1766/_index.html">How to fix OpenGL ES application crashes when moving to the background</a></p>

<p>但是在iOS8中，即使不是切换到后台，而是通过<code>NavigationController</code>切换到另一个ViewController再切回来，也会引起崩溃，崩溃点在：</p>

<p>``` c</p>

<pre><code>[EAGLContext presentRenderbuffer:GL_RENDERBUFFER];
</code></pre>

<p>```</p>

<p>猜测可能是，在iOS 8中，如果OpenGL的视图如果切换到不可见的ViewController，也需要停止绘制，否则也会引起在后台渲染OpenGL类似的崩溃。</p>

<h3>3.1 解决方法</h3>

<p>在ViewWillDisapper的时候停止渲染。</p>

<p>``` c</p>

<pre><code>- (void)viewWillDisappear:(BOOL)animated
{
    [super viewWillDisappear:animated];

    if (_videoView &amp;&amp; IsIOS8) {
        [_videoView pauseVideo];
    }
}

- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear:animated];

    if (_videoView &amp;&amp; IsIOS8) {
        [_videoView resumeVideo];
    }
}
</code></pre>

<p>```</p>

<p>iOS的兼容真是个蛋疼的问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XCode无法正确import预编译文件.pch里的头文件]]></title>
    <link href="http://blog.lessfun.com/blog/2014/09/18/xcode-not-load-all-headers-in-prefix-pch/"/>
    <updated>2014-09-18T11:13:56+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/09/18/xcode-not-load-all-headers-in-prefix-pch</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2014/09/lessfun_xcode_reload_pch_1.png" title="&lsquo;lessfun_xcode_reload_pch_1&rsquo; &lsquo;lessfun_xcode_reload_pch_1&rsquo;" ></p>

<!--more-->


<p>如图。我在<code>xx-Prefix.pch</code>预编译文件中添加了<code>#import "YYMacro.h"</code>，其中定义了一些公共常用的宏和常量。这样就不需要在每个源文件中再import一次，节省代码并且可以提高便以速度。</p>

<p>大部分情况下，一切工作正常。但是，偶尔，XCode会出现一些Bug，导致无法完全加载pch里的头文件，而代码里用到的在Macro.h中定义的常量，全部被标识为未定义：</p>

<p><img class="center" src="/images/2014/09/lessfun_xcode_reload_pch_2.png" title="&lsquo;lessfun_xcode_reload_pch_2&rsquo; &lsquo;lessfun_xcode_reload_pch_2&rsquo;" ></p>

<p>虽然不影响编译运行，但是却让代码可读性变得很差，无法正常自动补全。试过了以下方法：</p>

<ul>
<li>重启XCode</li>
<li>Product &ndash; Clean</li>
<li>Build &ndash; Run</li>
</ul>


<p>无果。<br/>
摸索并搜索之后，找到了<a href="http://stackoverflow.com/questions/11840622/xcode-4-4-does-not-get-all-the-pch-file-headers-imports">解决方法</a>。</p>

<h3>解决方法</h3>

<h4>1. 打开DerivedData目录</h4>

<p>打开<code>Window</code>&ndash;<code>Organizer</code>，点击<code>右箭头</code>：</p>

<p><img class="center" src="/images/2014/09/lessfun_xcode_reload_pch_3.png" title="&lsquo;lessfun_xcode_reload_pch_3&rsquo; &lsquo;lessfun_xcode_reload_pch_3&rsquo;" ></p>

<h4>2. 定位到Index &ndash; PrecompiledHeaders</h4>

<p><img class="center" src="/images/2014/09/lessfun_xcode_reload_pch_4.png" title="&lsquo;lessfun_xcode_reload_pch_4&rsquo; &lsquo;lessfun_xcode_reload_pch_4&rsquo;" ></p>

<h4>3. 删掉相关的预编译头文件目录</h4>

<p>由于XCode打开的可能是Workspace，包含了多个工程，而大部分工程的pch工作正常，所以我们不需要删除整个<code>PrecompiledHeaders</code>，只需要删除无法正常工作的工程的相关目录，就是以工程名为前缀的那几个。</p>

<h4>4. 重新编译</h4>

<p>现在，一切又正常了。</p>

<p><img class="center" src="/images/2014/09/lessfun_xcode_reload_pch_5.png" title="&lsquo;lessfun_xcode_reload_pch_5&rsquo; &lsquo;lessfun_xcode_reload_pch_5&rsquo;" ></p>

<h3>结论</h3>

<p>与XCode相关的Bug，比如变量无法正确被加载，头文件没有被import，修改了xib文件但是在模拟器中不起作用，等等，都可以通过删除<code>DerivedData</code>的中间文件解决。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Invalid Binary, the Binary Is Missing Architectures[arm64] - iTunes Connect的Bug]]></title>
    <link href="http://blog.lessfun.com/blog/2014/09/11/invalid-binary-the-binary-is-missing-architectures-arm64/"/>
    <updated>2014-09-11T14:51:58+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/09/11/invalid-binary-the-binary-is-missing-architectures-arm64</id>
    <content type="html"><![CDATA[<p>从昨天开始，网上iOS开发者哀鸿一片，因为提交App到AppStore的时候，都遇到了这样一个错误：</p>

<blockquote><p>「Today I cannot submit the binary to App Store, with the error &ldquo;Invalid binary, the binary is missing architectures[arm64]&rdquo;.」</p></blockquote>

<p>国内开发者也遇到了同样的问题：<br/>
<a href="http://bbs.lbsyun.baidu.com/redirect.php?tid=12550&amp;goto=lastpost">现在提交的新应用貌似必须支持arm64了</a></p>

<p><a href="http://www.cocoachina.com/ask/questions/show/119687">上传项目到APPstore，遇到的问题</a></p>

<p>公司内部这两天可能刚好不需要提交App，但是这是迟早的事，而项目中大部分引用的库都不支持arm64，未免开始紧张地修改工程编译选项，推动依赖库支持64位架构，沟通、协调、改错，乱成一团蚂蚁。</p>

<p>结果……苹果告诉我们，不好意思，让你们受惊了，这是我们的一个Bug！</p>

<!--more-->


<p>坑爹呢这是！<br/>
<img src="/images/2014/09/keng_die_ne.jpg" alt="ios_tabbar_running" /></p>

<p>苹果开发者论坛里的员工TimT如是说：</p>

<blockquote><p>「Yes, there was a fix recently applied to the server. Everyone should be able to submit 32-bit apps again.」</p></blockquote>

<p><img src="/images/2014/09/invalid_arm64.png" alt="ios_tabbar_running" /> <br/>
<a href="https://devforums.apple.com/message/1039265#1039265">32. Re: Invalid binary, the binary is missing architectures[arm64]</a></p>

<p>居然Sorry也没一句！任你乱如蚂蚁，我自泰然自若。</p>

<p>好了，没啥事了，还不能洗洗睡，继续提交32位App去吧~</p>

<p>PS: 查看.a库或.framework文件支持那些架构的方法如下：</p>

<p>``` bash
; .a
$cd libs
$lipo -info *.a
Architectures in the fat file: libssl.a are: i386 armv7 armv7s</p>

<p>; .framework
$cd xxFramework.framework
$lipo -info xxFramework
Architectures in the fat file: xxFramework are: armv7 armv7s i386</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在UINavigationController中使用UITabBarController，处理Two-stage Rotation错误]]></title>
    <link href="http://blog.lessfun.com/blog/2014/01/15/using-uitabbarcontroller-inside-uinavigationcontroller/"/>
    <updated>2014-01-15T12:12:51+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/01/15/using-uitabbarcontroller-inside-uinavigationcontroller</id>
    <content type="html"><![CDATA[<p>写iOS应用时，经常需要将UITabBarController嵌入到一个根UINavigationController中，如果处理不好，我们会遇到这样的错误：</p>

<pre><code>Two-stage rotation animation is deprecated. This application should use the smoother single-stage animation.
</code></pre>

<p>网上找了一下，StackOverFlow的<a href="http://stackoverflow.com/a/6637554">这个答案</a>说，不应该将UITabBarControllier嵌入到UINavigationController中作为rootViewController，但是，我们的确想要这样做，所以只好寻找其它办法。不过，至少我们可以确定的是，问题出在rootViewController同时包含UITabBarController和UINavigationController。</p>

<!--more-->


<p>几经尝试，最后发现，在设置为<code>window.rootViewController</code>之前，先指定<code>tabBarController.selectedIndex = 0</code>，问题解决。</p>

<p>可以得出，出现上述错误，是因为XCode不知道你需要push哪个子viewController，在加载navigationController的时候，不知道要载入哪一个controller，于是无脑的将tabBarController的viewControllers都动画载入了。</p>

<p>完整代码如下：</p>

<p>``` cpp
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>self.window = [[UIWindow alloc] initWithFrame:[[UIScreen mainScreen] bounds]];

UIStoryboard *storyBoard = [UIStoryboard storyboardWithName:@"Main" bundle:nil];

UINavigationController *navVC = [storyBoard instantiateInitialViewController];
//MainViewController是UITabBarController的子类
MainViewController *rootVC = (MainViewController *)navVC.visibleViewController;
rootVC.delegate = self;
rootVC.selectedIndex = 0;   //需要这样设置

self.window.rootViewController = navVC;

self.window.backgroundColor = [UIColor whiteColor];
[self.window makeKeyAndVisible];
return YES;
</code></pre>

<p>}
```</p>

<p>StoryBoard：</p>

<p><img src="/images/2014/01/ios_tabbar_storyboard.png" alt="ios_tabbar_storyboard" /></p>

<p>运行效果：</p>

<p><img src="/images/2014/01/ios_tabbar_running.png" alt="ios_tabbar_running" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[修复iOS中UIScrollView的scrollToTop设置后不生效的问题]]></title>
    <link href="http://blog.lessfun.com/blog/2014/01/13/fix-uiscrollview-scrolltotop-not-working/"/>
    <updated>2014-01-13T15:15:04+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/01/13/fix-uiscrollview-scrolltotop-not-working</id>
    <content type="html"><![CDATA[<p>iOS中的<code>UIScrollView</code>有一个属性<code>scrollToTop</code>，设置为<code>YES</code>之后，点击设备的状态栏(StatusBar)即可将滚动试图的内容滚动到最顶端，在滚动列表很长的时候，这个特性十分有用。</p>

<p>今日在使用这一属性的时候，发现部分情况下，一切正常；但是也有时候，点击状态栏，滚动条没反应！检查了代码，确定已经设置<code>scrollToTop = YES</code>，但是总是会有不起作用的情况。</p>

<p>于是到万能的StackOverflow寻求答案，不失所望，找到了类似的问题：<a href="http://stackoverflow.com/questions/8951357/scroll-uitableview-to-top-when-tapping-top-of-the-screen">scroll UITableView to top when tapping top of the screen</a></p>

<p>答案也解释得很清楚了，如下：</p>

<!--more-->


<p>如果同一个UIViewController中包含了多个UIScrollView，那么只能有一个ScrollView被设置为scrollToTop = YES; 另外的都要设置为NO，否则就会被系统忽略。
比较坑爹的是，该属性默认为YES，在<code>UIScrollView.h</code>中可以看到声明如下：</p>

<p><code>cpp
  @property(nonatomic) BOOL  scrollsToTop;  // default is YES.
</code></p>

<p>所以我们需要显示设置其他的<code>scrollView.scrollToTop = NO</code>。</p>
]]></content>
  </entry>
  
</feed>
