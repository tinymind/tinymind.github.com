<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 浮生猎趣]]></title>
  <link href="http://blog.lessfun.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.lessfun.com/"/>
  <updated>2014-11-22T16:35:02+08:00</updated>
  <id>http://blog.lessfun.com/</id>
  <author>
    <name><![CDATA[lslin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[到底什么时候才需要在ObjC的Block中使用weakSelf/strongSelf]]></title>
    <link href="http://blog.lessfun.com/blog/2014/11/22/when-should-use-weakself-and-strongself-in-objc-block/"/>
    <updated>2014-11-22T15:59:18+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/11/22/when-should-use-weakself-and-strongself-in-objc-block</id>
    <content type="html"><![CDATA[<p>Objective C 的 <code>Block</code> 是一个很实用的语法，特别是与GCD结合使用，可以很方便地实现并发、异步任务。但是，如果使用不当，Block 也会引起一些循环引用问题(<code>retain cycle</code>)—— Block 会 retain ‘self’，而 ‘self‘ 又 retain 了 Block。因为在 ObjC 中，直接调用一个实例变量，会被编译器处理成 &lsquo;self->theVar'，'self&rsquo; 是一个 strong 类型的变量，引用计数会加 1，于是，self retains queue， queue retains block，block retains self。</p>

<!--more-->


<h3>解决 retain circle</h3>

<p>Apple 官方的建议是，传进 Block 之前，把 &lsquo;self&rsquo; 转换成 weak automatic 的变量，这样在 Block 中就不会出现对 self 的强引用。如果在 Block 执行完成之前，self 被释放了，weakSelf 也会变为 nil。</p>

<p>示例代码：</p>

<p>``` m</p>

<p><strong>weak </strong>typeof__(self) weakSelf = self;</p>

<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
[weakSelf doSomething];
</code></pre>

<p>});</p>

<p>```</p>

<p>clang 的文档表示，在 doSomething 内，weakSelf 不会被释放。但，下面的情况除外：</p>

<p>``` m</p>

<p><strong>weak </strong>typeof__(self) weakSelf = self;</p>

<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
[weakSelf doSomething];
[weakSelf doOtherThing];
</code></pre>

<p>});</p>

<p>```</p>

<p>在 doSomething 中，weakSelf 不会变成 nil，不过在 doSomething 执行完成，调用第二个方法 doOtherThing 的时候，weakSelf 有可能被释放，于是，strongSelf 就派上用场了：</p>

<p>``` m</p>

<p><strong>weak </strong>typeof__(self) weakSelf = self;</p>

<pre><code>dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
__strong __typeof(self) strongSelf = weakSelf;
[strongSelf doSomething];
[strongSelf doOtherThing];
</code></pre>

<p>});</p>

<p>```</p>

<p><code>__strong</code> 确保在 Block 内，strongSelf 不会被释放。</p>

<h3>总结</h3>

<ul>
<li>在 Block 内如果需要访问 self 的方法、变量，建议使用 weakSelf。</li>
<li>如果在 Block 内需要多次 访问 self，则需要使用 strongSelf。</li>
</ul>


<h3>参考</h3>

<ul>
<li><a href="http://dhoerl.wordpress.com/2013/04/23/i-finally-figured-out-weakself-and-strongself/">I finally figured out weakSelf and strongSelf</a></li>
<li><a href="http://stackoverflow.com/questions/21113963/is-the-weakself-strongself-dance-really-necessary-when-referencing-self-inside-a?rq=1">Is the weakSelf/strongSelf dance really necessary when referencing self inside a non-retained completion called from a UIViewController?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 6.1 iPhone Simulator 8.1 Keyboard Issue：键盘无法显示，设置inputAccessoryView崩溃]]></title>
    <link href="http://blog.lessfun.com/blog/2014/10/24/xcode-6-dot-1-iphone-simulator-8-dot-1-keyboard-issue/"/>
    <updated>2014-10-24T14:42:51+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/10/24/xcode-6-dot-1-iphone-simulator-8-dot-1-keyboard-issue</id>
    <content type="html"><![CDATA[<p>随着iPhone 6 &amp; Plus的发布，苹果也陆续更新了XCode和开发模拟器，目前最新的Xcode版本是6.1，内置的Simulator的iOS版本是8.1。也许你兴致冲冲迫不及待地一下子升级到了最新版的开发环境，那么可能会遇到一些键盘上的问题：无法弹出键盘，或者弹出键盘后会莫名其妙地崩溃。</p>

<p>当然，不能怪你，你的项目在iOS7.1上是运行地好好的。只能怪苹果没有推出一个完美无Bug的开发工具。</p>

<!--more-->


<h2>1. 在XCode 6，iOS 8.1模拟器无法弹出键盘</h2>

<p>解决方法很简单，在Simulator的系统菜单中，取消勾选：</p>

<p><code>Hardware</code> &ndash;> <code>Keyboard</code> &ndash;> <code>Connect Hardware Keyboard</code>。</p>

<p>取消选中之后，键盘可以正常弹出，但是，无法使用硬件的键盘输入了，自己慢慢用鼠标点击模拟器里的键盘吧……</p>

<h2>2. 弹出键盘后会莫名其妙地崩溃</h2>

<p>也许你键盘能正常显示了，但是一显示就崩溃，在堆栈中有这样的字样：</p>

<p>``` m</p>

<pre><code>*** First throw call stack:
(
    0   CoreFoundation                      0x02101df6 __exceptionPreprocess + 182
    1   libobjc.A.dylib                     0x01d8ba97 objc_exception_throw + 44
    2   CoreFoundation                      0x02101d1d +[NSException raise:format:] + 141
    3   UIKit                               0x008cff9c -[UIViewController _addChildViewController:performHierarchyCheck:notifyWillMove:] + 210
    4   UIKit                               0x00f4b44d -[UIInputWindowController changeToInputViewSet:] + 576
    5   UIKit                               0x00f4c1be __43-[UIInputWindowController setInputViewSet:]_block_invoke + 103
    6   UIKit                               0x007f73bf +[UIView(Animation) performWithoutAnimation:] + 82
    7   UIKit                               0x00f4bf9c -[UIInputWindowController setInputViewSet:] + 374
    8   UIKit                               0x00ce9101 __64-[UIPeripheralHost(UIKitInternal) setInputViews:animationStyle:]_block_invoke1459 + 43
    9   UIKit                               0x00f473af -[UIInputWindowController performOperations:withAnimationStyle:] + 56

......
}
</code></pre>

<p>```</p>

<p>以上崩溃也只在XCode 6，iOS 8出现，在iOS 7一切正常。</p>

<p>原因可能是你设置了<code>UITextField</code>或<code>UITextView</code>的<code>inputView</code>或<code>inputAccessoryView</code>为customView，比如这样：</p>

<p>``` m</p>

<pre><code>//在Xib或Storyboard中创建了一个自定义View
@property (strong, nonatomic) IBOutlet UIView *switchKeyboardBar;

...

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.textView.inputAccessoryView = self.switchKeyboardBar;
}
</code></pre>

<p>```</p>

<p>上述代码在iOS 8中是必定Crash的，因为<code>UITextView.inputAccessoryView</code>不能是其他View的子View。而上面的<code>switchKeyboardBar</code>先被添加到了当前<code>UIViewController</code>的<code>View</code>中，再被设置到<code>inputAccessoryView</code>，就会导致崩溃。</p>

<h3>2.1 解决方法</h3>

<p>不从Xib创建自定义View，而是在代码中手动创建，并且不添加到别的View中。</p>

<p>如下：</p>

<p>``` m</p>

<pre><code>//注意这里没有 IBOutlet
@property (strong, nonatomic) UIView *switchKeyboardBar;

- (UIView *)switchKeyboardBar
{
    if (!_switchKeyboardBar) {
        _switchKeyboardBar = [[UIView alloc] initWithFrame:CGRectMake(0, 0, CGRectGetWidth(self.view.frame), 40)];

        //add other subviews
        ...
    }
    return _switchKeyboardBar;
}

- (void)viewDidLoad
{
    [super viewDidLoad];

    self.textView.inputAccessoryView = self.switchKeyboardBar;
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS AutoLayout与AutoSizing：自动布局，想说爱你真的好难]]></title>
    <link href="http://blog.lessfun.com/blog/2014/10/17/ios-autolayout-vs-autosizing/"/>
    <updated>2014-10-17T14:31:20+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/10/17/ios-autolayout-vs-autosizing</id>
    <content type="html"><![CDATA[<p>在iPhone Retina发布之前，还没有AutoLayout，因为屏幕只有一种尺寸。<br/>
当iPhone Retina发布之后，我没有用上AutoLayout，因为屏幕尺寸是用点来表示，布局写起来没什么不同。<br/>
当iPhone 5发布之后，屏幕尺寸终于加长了，但是由于有AutoSizing，所以我还是可以不用AutoLayout。<br/>
现在，iPhone 6和6 Plus发布了，屏幕又大了，我不得不开始考虑是否要使用AutoLayout。</p>

<!--more-->


<h2>1. Autolayout 与 Autosizing的区别</h2>

<p>虽然自iOS6之后，苹果推荐我们使用Autolayout布局，并且在Xib和Storyboard中默认帮我们打开了这个选项，但是在开发过程中，我们偏向于使用<code>Autosizing</code>，并且手动取消掉<code>Autolayout</code>，原因在于，Autolayout太繁琐复杂，而Autosizing简单并且能满足大部分的需求。</p>

<h3>Autosizing适用的情况</h3>

<p>当父视图被拉伸的时候，子视图能够适配父视图的新大小。其原理是，子视图有一个masks，用于指定与父视图上下左右边缘的距离，以及自身宽高的关系。</p>

<p>比如，指定子视图的右边缘紧跟着父视图的右边缘，那么父视图变大之后，子视图还是贴在父视图的右边。</p>

<p>这在大部分简单布局情况下非常有效。</p>

<h3>Autosizing的不足</h3>

<p>使用Autosizing，有一个前提，就是子视图的Frame是固定的，至少宽高是固定的，或者跟随着父视图的Frame变化。但是，如果希望多个子视图与父视图的边距固定，大小自动调整，Autosizing就爱莫能助了。</p>

<p>原因在于：<strong>Autosizing无法智能计算多个子View各自的Frame</strong>。</p>

<p>比如，我们希望在竖屏下布局是这样：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/StrutsProblem-portrait-design-423x500.png" alt="autosizing portrait" /></p>

<p>并且在横屏下布局是这样：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/StrutsProblem-landscape-looks-good-480x289.png" alt="autosizing landscape" /></p>

<p>除了手写代码调整Frame，单独用Autosizing是无法做到的。这时候就需要借助强大的Autolayout了。</p>

<h3>Autolayout的优点</h3>

<p>Autolayout使用约束来决定每个View的坐标、大小，约束可以针对SuperView，也可以针对其他任意一个SubView。</p>

<p>使用自动布局，你可以表达出视图与视图之间的关系，而不是明确地指定每个视图的Frame。通过约束，视图会自动计算它们应该呆在哪个位置，只要约束足够多，它们也能自动计算自己的大小。</p>

<p>只要指定了约束，无论屏幕大小怎么变化，它们都能自适应，这就是Autolayout的优点：妈妈再也不用担心你手写布局代码啦！也不用担心你为了适配各种屏幕大小而加班了。</p>

<h3>Autolayout的缺点</h3>

<p>Autolayout唯一的缺点就在于：过于复杂，较难上手。</p>

<h3>使用Autolayout，还是Autosizing？</h3>

<p>取决于项目需求。如果Autosizing完全能满足开发需求，那么就没必要使用复杂的Autolayout。但是，如果你已经被适配各种屏幕大小折腾得不成人形了，那么就要早日投入到Autolayout的怀抱了。</p>

<h2>Autolayout的使用</h2>

<p>首先要改变自己对布局的思考方式。你应该忘掉Frame，需要考虑的是subView A与subView B的上下左右的关系，以及与superView的关系。</p>

<h3>借助XCode</h3>

<p>在Xcode5之后，苹果已经尽力让开发者能更方便地使用Autolayout了。<br/>
通过<code>Xcode</code>&ndash;><code>Editor</code>&ndash;><code>Pin/Align</code>菜单为视图添加约束即可。</p>

<p>在XCode中除了通过菜单，还可以通过可视化的方式添加约束：</p>

<p><img src="http://cdn4.raywenderlich.com/wp-content/uploads/2013/09/Pin-green-view.png" alt="autolayout add constraint" /></p>

<p>如果你添加的约束不足以表达某个View的位置大小，XCode还会以黄色的辅助线发出警告，十分好用。</p>

<h3>手写约束Constraint</h3>

<p>XCode虽然强大，但是有时候我们也许希望借助代码来写Constraint。</p>

<p>加入你希望一个子view跟随父view的大小，但是与边距有10个点的距离：</p>

<p>``` m</p>

<p>UIView *superview = self;</p>

<p>UIView *view1 = [[UIView alloc] init];
view1.translatesAutoresizingMaskIntoConstraints = NO;
view1.backgroundColor = [UIColor greenColor];
[superview addSubview:view1];</p>

<p>UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);</p>

<p>[superview addConstraints:@[</p>

<pre><code>//view1 constraints
[NSLayoutConstraint constraintWithItem:view1
                             attribute:NSLayoutAttributeTop
                             relatedBy:NSLayoutRelationEqual
                                toItem:superview
                             attribute:NSLayoutAttributeTop
                            multiplier:1.0
                              constant:padding.top],

[NSLayoutConstraint constraintWithItem:view1
                             attribute:NSLayoutAttributeLeft
                             relatedBy:NSLayoutRelationEqual
                                toItem:superview
                             attribute:NSLayoutAttributeLeft
                            multiplier:1.0
                              constant:padding.left],

[NSLayoutConstraint constraintWithItem:view1
                             attribute:NSLayoutAttributeBottom
                             relatedBy:NSLayoutRelationEqual
                                toItem:superview
                             attribute:NSLayoutAttributeBottom
                            multiplier:1.0
                              constant:-padding.bottom],

[NSLayoutConstraint constraintWithItem:view1
                             attribute:NSLayoutAttributeRight
                             relatedBy:NSLayoutRelationEqual
                                toItem:superview
                             attribute:NSLayoutAttributeRight
                            multiplier:1
                              constant:-padding.right],
</code></pre>

<p> ]];</p>

<p>```</p>

<p>每个约束都是这样的长长一串代码，设想一下需要添加6个约束的话……</p>

<p>幸好有了这个开源库：<a href="https://github.com/Masonry/Masonry">Masonry</a>。</p>

<p>使用这个库，代码添加约束就可以简介如下：</p>

<p>``` m</p>

<p>[view1 mas_makeConstraints:^(MASConstraintMaker *make) {</p>

<pre><code>make.edges.equalTo(superview).with.insets(padding);
</code></pre>

<p>}];</p>

<p>```</p>

<h3>更新约束</h3>

<p>比如，我们自己实现了一个图文混排的TextView，添加到Xib时我们还不知道其高度，需要在代码中计算，那么就需要在代码里更新约束，如：</p>

<p>``` m</p>

<p>@property (strong, nonatomic) IBOutlet NSLayoutConstraint *richTextHeightConstraint;</p>

<p>&hellip;</p>

<ul>
<li><p>(void)relayout
{
  self.richTextHeightConstraint.constant = self.richTextView.frame.size.height;</p>

<p>  [self needsUpdateConstraints];
}</p></li>
</ul>


<p>```</p>

<h2>关键还是实践</h2>

<p>多说无益，贵在实践。只要有意识地去使用了一次，自然就会了。</p>

<h3>参考链接</h3>

<ul>
<li><a href="http://www.raywenderlich.com/50317/beginning-auto-layout-tutorial-in-ios-7-part-1">Beginning Auto Layout Tutorial in iOS 7: Part 1</a></li>
<li><a href="http://www.raywenderlich.com/50319/beginning-auto-layout-tutorial-in-ios-7-part-2">Beginning Auto Layout Tutorial in iOS 7: Part 2</a></li>
<li><a href="http://www.cocoachina.com/industry/20131203/7462.html">开始iOS 7中自动布局教程 一</a></li>
<li><a href="http://www.cnblogs.com/zer0Black/p/3977288.html">开始iOS 7中自动布局教程 二</a></li>
<li><a href="http://segmentfault.com/blog/ilikewhite/1190000000646452">从此爱上iOS Autolayout</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS通过宏定义快速调整View的Frame]]></title>
    <link href="http://blog.lessfun.com/blog/2014/10/15/ios-adjust-view-frame-quickly-with-macro/"/>
    <updated>2014-10-15T18:45:03+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/10/15/ios-adjust-view-frame-quickly-with-macro</id>
    <content type="html"><![CDATA[<p>在iOS开发中，经常需要在运行时动态修改View Frame，比如，theView的X坐标右移2个点，Y坐标下移2个点，常用的方法如下：</p>

<p>``` c</p>

<pre><code>CGRect newFrame = self.theView.frame;
newFrame.origin.x += 2;
newFrame.origin.y += 2;
self.theView.frame = newFrame;
</code></pre>

<p>```</p>

<p>逻辑很简单，就是代码繁琐了点，设想一下，假如有5个以上的子View需要调整位置与大小……</p>

<!--more-->


<h3>解决方法</h3>

<p>也很简单，就是封装为通用的宏，或者方法(有些人比较反感C语言样式的宏定义)。</p>

<p>``` c</p>

<pre><code>#define CGRectAdjust(r, x1, y1, w1, h1)    CGRectMake(r.origin.x + x1, r.origin.y + y1,  r.size.width + w1, r.size.height + h1)
#define CGRectSetSize(r, w, h)    CGRectMake(r.origin.x, r.origin.y, w, h)
#define CGRectSetOrigin(r, x, y)    CGRectMake(x, y, r.size.width, r.size.height)

#define ViewAdjustFrame(view, x1, y1, w1, h1)   view.frame = CGRectAdjust(view.frame, x1, y1, w1, h1)
#define ViewSetSize(view, w, h)   view.frame = CGRectSetSize(view.frame, w, h)
#define ViewSetOrigin(view, x, y)   view.frame = CGRectSetOrigin(view.frame, x, y)
</code></pre>

<p>```</p>

<p>然后，就可以这样调整UIView的Frame了：</p>

<p>``` c</p>

<pre><code>//大小不变，位置往右下方移动2个点
ViewAdjustFrame(theView, 2, 2, 0, 0);
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[App适配iOS8遇到的兼容问题：键盘方向与StatusBar方向不一致，阻止锁屏失效，OpenGL崩溃]]></title>
    <link href="http://blog.lessfun.com/blog/2014/09/24/ios8-issue-keyboard-orientation-and-idletimerdisabled-not-working/"/>
    <updated>2014-09-24T13:59:29+08:00</updated>
    <id>http://blog.lessfun.com/blog/2014/09/24/ios8-issue-keyboard-orientation-and-idletimerdisabled-not-working</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/2014/09/lessfun_ios8_adapt.png" title="&lsquo;ios8 adapt&rsquo; &lsquo;ios8 adapt&rsquo;" >
苹果正式发布iOS8系统，到现在安装覆盖率已达48%，而iOS7的安装率是49%。所以，各位开发者又有得忙了，把所有的App都升级并适配到iOS8系统可不是一件轻松的事。</p>

<p>下面罗列一下我在适配iOS8过程中遇到的兼容问题——而同样的代码在iOS6/7是完全没问题的。</p>

<!--more-->


<h2>1. 键盘弹出方向与StatusBar方向不一致</h2>

<p>在App中，第一个ViewController是只支持竖屏方向(Portrait)的，切换到第二个页面，默认也是Portrait，但用户可以点击按钮切换为横屏(Landscape)。</p>

<p>所以，我把App-Info.plist只选中了<code>Portrait</code>一项，并且在<code>Root ViewController</code>重载了以下方法：</p>

<p>``` c</p>

<pre><code>- (BOOL)shouldAutorotate
{
    return NO;
}

- (NSUInteger)supportedInterfaceOrientations
{
    return UIInterfaceOrientationMaskPortrait;
}

- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation
{
    return UIInterfaceOrientationPortrait;
}
</code></pre>

<p>```</p>

<p>然后在需要切换到横屏的时候，调用以下代码：</p>

<p>``` c</p>

<ul>
<li>(void)onFullScreenButtonTouchUpInside:(id)sender
{
  [self adjustViewFrameToFullScreen];
  [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight animated:NO];
}</li>
</ul>


<p>```</p>

<p>由于在iOS6、7中，键盘方向是跟随状态栏方向的，所以一切表现正常，横屏下，无论设备方向怎样，键盘都是横着弹出。</p>

<p>但是，在iOS8中，键盘却随着设备方向弹出了。换言之，<strong>即使Interface Orientation为Landscape，但Device Orientation为Portrait，键盘就会以Portrait的方向弹出</strong>。<br/>
如下图：</p>

<p><img class="center" src="/images/2014/09/lessfun_ios8_adapt_keyboard.png" title="&lsquo;ios8 adapt keyboard&rsquo; &lsquo;ios8 adapt keyboard&rsquo;" ></p>

<h3>1.1 解决方法</h3>

<p>我想要的是键盘不管设备方向，只关注状态栏方向，也就是StatusBarOrientation。由于iOS8新出不久，在网上没找到解决方案。后来我一同事发现手动更改设备方向可以解决这一问题：</p>

<p>``` c</p>

<ul>
<li>(void)onFullScreenButtonTouchUpInside:(id)sender
{
  [self adjustViewFrameToFullScreen];
  [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight animated:NO];
  //改设备方向
  if (IsIOS8) {
      [[UIDevice currentDevice] setValue:[NSNumber numberWithInteger:UIDeviceOrientationLandscapeLeft] forKey:@&ldquo;orientation&rdquo;];
  }
}</li>
</ul>


<p>```</p>

<h2>2. 禁用屏幕自动锁定失效</h2>

<p>本来，防止屏幕锁定只需一句代码：</p>

<p>``` c</p>

<pre><code>[[UIApplication sharedApplication] setIdleTimerDisabled:YES];
</code></pre>

<p>```</p>

<p>但是，在iOS8中，偶尔会失效。测试人员发现了这个问题是在弹出键盘点击发送后必现，而原因不明。因为键盘出现与隐藏，理论上不应该影响这个<code>idleTimerDisabled</code>的属性。暂且认为是iOS8的Bug吧。</p>

<h3>2.1 解决方法</h3>

<p>在键盘收起的时候，重设<code>IdleTimerDisabled</code>。</p>

<p>``` c</p>

<pre><code>- (void)onKeyboardDidHide:(NSNotification *)notification
{
    if (IsIOS8) {
        [[UIApplication sharedApplication] setIdleTimerDisabled:YES];
    }
}
</code></pre>

<p>```</p>

<h2>3. OpenGL ES渲染时崩溃</h2>

<p>在iOS中使用OpenGL ES渲染，切换到后台时需要停止渲染，否则会引起崩溃。见这里：<a href="https://developer.apple.com/library/ios/qa/qa1766/_index.html">How to fix OpenGL ES application crashes when moving to the background</a></p>

<p>但是在iOS8中，即使不是切换到后台，而是通过<code>NavigationController</code>切换到另一个ViewController再切回来，也会引起崩溃，崩溃点在：</p>

<p>``` c</p>

<pre><code>[EAGLContext presentRenderbuffer:GL_RENDERBUFFER];
</code></pre>

<p>```</p>

<p>猜测可能是，在iOS 8中，如果OpenGL的视图如果切换到不可见的ViewController，也需要停止绘制，否则也会引起在后台渲染OpenGL类似的崩溃。</p>

<h3>3.1 解决方法</h3>

<p>在ViewWillDisapper的时候停止渲染。</p>

<p>``` c</p>

<pre><code>- (void)viewWillDisappear:(BOOL)animated
{
    [super viewWillDisappear:animated];

    if (_videoView &amp;&amp; IsIOS8) {
        [_videoView pauseVideo];
    }
}

- (void)viewWillAppear:(BOOL)animated
{
    [super viewWillAppear:animated];

    if (_videoView &amp;&amp; IsIOS8) {
        [_videoView resumeVideo];
    }
}
</code></pre>

<p>```</p>

<p>iOS的兼容真是个蛋疼的问题。</p>
]]></content>
  </entry>
  
</feed>
