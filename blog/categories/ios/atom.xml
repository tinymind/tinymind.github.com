<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 浮生猎趣]]></title>
  <link href="http://blog.lessfun.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://blog.lessfun.com/"/>
  <updated>2017-08-17T20:31:17+08:00</updated>
  <id>http://blog.lessfun.com/</id>
  <author>
    <name><![CDATA[lslin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS 10 ReplayKit Live 与 Broadcast UI/Upload Extension]]></title>
    <link href="http://blog.lessfun.com/blog/2016/09/21/ios-10-replaykit-live-and-broadcast-extension/"/>
    <updated>2016-09-21T11:47:55+08:00</updated>
    <id>http://blog.lessfun.com/blog/2016/09/21/ios-10-replaykit-live-and-broadcast-extension</id>
    <content type="html"><![CDATA[<p>在 iOS 8 及以前，第三方 App 如果想要全局录屏，只能使用私有 API，详见<a href="http://blog.lessfun.com/blog/2015/12/25/ios-record-screen-in-background/">非越狱后台录屏</a>。</p>

<p>升级到 iOS 9 后，官方新增了 ReplayKit，并且禁用了录屏的私有 API。ReplayKit 并不算是完美的录屏方案，如果想要把梦幻西游的游戏过程录制下来，需要梦幻西游这个应用本身添加 ReplayKit 的支持，然后再把录制的视频分享出去。对于不支持 ReplayKit 的游戏，怎么录制？答案是，没有办法。试想，又有多少个游戏会内置 ReplayKit 呢？</p>

<p>iOS 10 在 iOS 9 的 ReplayKit 保存录屏视频的基础上，增加了视频流实时直播功能（streaming live），官方介绍见 <a href="http://devstreaming.apple.com/videos/wwdc/2016/601nsio90cd7ylwimk9/601/601_go_live_with_replaykit.pdf">Go Live with ReplayKit</a>。下面详细说说这个流程。</p>

<!--more-->


<h2>1. ReplayKit Live 概述</h2>

<p>从录制到直播，整体流程如下：</p>

<ol>
<li>被录制端需引入 ReplayKit，发起广播请求。</li>
<li>广播端需要实现 Broadcast UI 和 Broadcast Upload 两个 <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH20-SW1">App Extension</a>，以便出现在被录制端的 App 列表。</li>
<li>被录制端选定广播端 App 后，开始直播。</li>
</ol>


<p>其中，<code>被录制端</code>可以是任意一个 App，如梦幻西游，<code>广播端</code>是支持 ReplayKit Live 的直播平台，如虎牙直播。</p>

<p><img src="/images/2016/09/replaykit_workflow.png" alt="ReplayKit WorkFlow" /></p>

<h2>2. 被录制端（游戏或应用）的实现</h2>

<p>被录制端需要在原有功能的基础上，增加一个唤起广播的入口。代码：</p>

<p>``` objc</p>

<h1>import &lt;ReplayKit/ReplayKit.h></h1>

<ul>
<li>(IBAction)onLiveButtonPressed:(id)sender {
  [RPBroadcastActivityViewController loadBroadcastActivityViewControllerWithHandler:^(RPBroadcastActivityViewController * <em>Nullable broadcastActivityViewController, NSError * </em>Nullable error) {
      self.broadcastAVC = broadcastActivityViewController;
      self.broadcastAVC.delegate = self;
      [self presentViewController:self.broadcastAVC animated:YES completion:nil];
  }];
}</li>
</ul>


<h1>pragma mark &ndash; RPBroadcastActivityViewControllerDelegate</h1>

<ul>
<li><p>(void)broadcastActivityViewController:(RPBroadcastActivityViewController <em>)broadcastActivityViewController didFinishWithBroadcastController:(nullable RPBroadcastController </em>)broadcastController error:(nullable NSError *)error {</p>

<p>  [self.broadcastAVC dismissViewControllerAnimated:YES completion:nil];</p>

<p>  self.broadcastController = broadcastController;
  [broadcastController startBroadcastWithHandler:^(NSError * _Nullable error) {
      if (!error) {
          self.liveButton.selected = YES;
      } else {
          NSLog(@&ldquo;startBroadcastWithHandler error: %@&rdquo;, error);
      }
  }];
}</p></li>
</ul>


<p>```</p>

<p>如下图的右上角就是开始广播的入口按钮。</p>

<p><img src="/images/2016/09/replaykit_demo_init.png" alt="ReplayKit Demo Init" /></p>

<p>如果手机内没有支持广播的 App，会弹框提示到 App Store 查找一个。</p>

<p><img src="/images/2016/09/replaykit_demo_choose.png" alt="ReplayKit Demo Choose" /></p>

<p>如果已经安装支持广播的 App，则会列出，点击后会打开广播端的 Broadcast UI。</p>

<p><img src="/images/2016/09/replaykit_demo_list.png" alt="ReplayKit Demo List" /></p>

<p>下面要说的就是怎么实现一个支持广播的 App。</p>

<h2>3. 广播端（直播平台）的实现</h2>

<p>很多直播 App 本身已经支持通过摄像头进行视频流上传、直播，新增对 ReplayKit Live 的支持，只需要创建两个扩展的 target，分别是 Broadcast UI Extension 和 Broadcast Upload Extension，在XCode 8 中内置了这两个模板。</p>

<h3>3.1 Broadcast UI</h3>

<p>Broadcast UI 负责广播前的一些初始化工作，比如，让用户填写直播平台的账号、密码、直播标题。从被录制端唤起广播请求并选定广播平台后，会显示 Broadcast UI 界面。</p>

<p>核心代码：</p>

<p>``` objc</p>

<h1>import &lt;ReplayKit/ReplayKit.h></h1>

<p>@interface BroadcastViewController : UIViewController</p>

<p>@end</p>

<p>&hellip;</p>

<ul>
<li><p>(IBAction)onCancelButtonPressed:(id)sender {
  [self userDidCancelSetup];
}</p></li>
<li><p>(IBAction)onOKButtonPressed:(id)sender {
  if (self.accountTextField.text.length == 0
      || self.passwordTextField.text.length == 0
      || self.channelIDTextField.text.length == 0) {
      return;
  }
  [self userDidFinishSetup];
}</p></li>
</ul>


<h1>pragma mark &ndash; Private</h1>

<p>// Called when the user has finished interacting with the view controller and a broadcast stream can start
&ndash; (void)userDidFinishSetup {</p>

<pre><code>NSLog(@"userDidFinishSetup");

// Broadcast url that will be returned to the application
NSURL *broadcastURL = [NSURL URLWithString:@"http://broadcastURL_example/stream1"];

// Service specific broadcast data example which will be supplied to the process extension during broadcast
NSDictionary *setupInfo = @{@"account" : self.accountTextField.text,
                            @"password" : self.passwordTextField.text,
                            @"channelID" : @(self.channelIDTextField.text.integerValue)};

// Set broadcast settings
RPBroadcastConfiguration *broadcastConfig = [[RPBroadcastConfiguration alloc] init];
broadcastConfig.clipDuration = 5.0; // deliver movie clips every 5 seconds

// Tell ReplayKit that the extension is finished setting up and can begin broadcasting
[self.extensionContext completeRequestWithBroadcastURL:broadcastURL broadcastConfiguration:broadcastConfig setupInfo:setupInfo];
</code></pre>

<p>}</p>

<ul>
<li>(void)userDidCancelSetup {
  // Tell ReplayKit that the extension was cancelled by the user
  [self.extensionContext cancelRequestWithError:[NSError errorWithDomain:@&ldquo;YourAppDomain&rdquo; code:-1     userInfo:nil]];
}</li>
</ul>


<p>```</p>

<p>效果：</p>

<p><img src="/images/2016/09/replaykit_demo_broadcast_ui.png" alt="ReplayKit Demo List" /></p>

<p>如果用户点击 <code>OK</code>，则会回调到第二部分中的<code>RPBroadcastActivityViewControllerDelegate</code>，开始直播会调用 Broadcast Upload 扩展。</p>

<h3>3.2 Broadcast Upload</h3>

<p>第二部分调用<code>startBroadcastWithHandler</code>，会跑到<code>Broadcast Upload</code>，本扩展的作用是接收并处理 Broadcast UI 传过来的用户信息，以及处理 RPBroadcastController 传过来的音视频流数据，如编码、上传。</p>

<p>核心代码：</p>

<p>``` objc</p>

<h1>import &lt;ReplayKit/ReplayKit.h></h1>

<p>@interface SampleHandler : RPBroadcastSampleHandler</p>

<p>@end</p>

<p>&hellip;</p>

<p>//  To handle samples with a subclass of RPBroadcastSampleHandler set the following in the extension&rsquo;s Info.plist file:
//  &ndash; RPBroadcastProcessMode should be set to RPBroadcastProcessModeSampleBuffer
//  &ndash; NSExtensionPrincipalClass should be set to this class</p>

<p>@implementation SampleHandler</p>

<ul>
<li><p>(void)broadcastStartedWithSetupInfo:(NSDictionary<NSString *,NSObject *> *)setupInfo {
  // User has requested to start the broadcast. Setup info from the UI extension will be supplied.
  NSLog(@&ldquo;broadcastStartedWithSetupInfo: %@&rdquo;, setupInfo);
  [[ReplayKitUploader sharedObject] setupWithInfo:setupInfo];
}</p></li>
<li><p>(void)broadcastPaused {
  // User has requested to pause the broadcast. Samples will stop being delivered.
}</p></li>
<li><p>(void)broadcastResumed {
  // User has requested to resume the broadcast. Samples delivery will resume.
}</p></li>
<li><p>(void)broadcastFinished {
  // User has requested to finish the broadcast.
}</p></li>
<li><p>(void)processSampleBuffer:(CMSampleBufferRef)sampleBuffer withType:(RPSampleBufferType)sampleBufferType {
  [[ReplayKitUploader sharedObject] handleSampleBuffer:sampleBuffer withType:sampleBufferType];
}</p></li>
</ul>


<p>@end</p>

<p>```</p>

<h3>3.3 注意事项</h3>

<p><code>ReplayKitUploader</code> 是自定义的一个类，使用了单例模式，负责广播服务的登录、编码、上传功能。使用单例，而不是直接在 SampleHandler 里面处理，是因为 SampleHandler 并不是 Broadcast Upload Extension 里的唯一一个实例，实际上，Upload Extension 会不断地创建很多个 SampleHandler 来处理 CMSampleBufferRef，而我们为了保存一些内部状态，必须使用一个固定的类实例来实现。</p>

<h2>4. App 与 Extension 的代码共用</h2>

<p>iOS 10 新增了很多种 Extension，包括本文提到的两种 Broadcast Extension。主 App 与 Extension 属于不同的两个进程，代码逻辑也是分离的，而实际情况中，主 App 与 Extension 往往会包含相同的逻辑，需要共用代码。</p>

<p>主 App 与 Extension 属于两个不同的 target，共用代码，有以下几种方式：</p>

<ul>
<li>一份代码创建两个副本，分别加到 App 和 Extension 两个 target 中。这种方法简单粗暴而有效，只是，如果需要改动逻辑，则需要改两份代码，想象一下，假如这种改动很频繁，世界上又有几个程序员能受得了？</li>
<li>抽离公共代码，放到独立的 framework，然后两个 target 都依赖该 framework，这是标准而方便的做法。</li>
<li>使用 CocoaPods，只需要在 Podfile 中分别写两个 target 所依赖的 pod 即可，最简洁。</li>
</ul>


<h2>5. 结论</h2>

<p>在 iOS 环境中，想要共享设备屏幕，无论是录播还是直播，都注定了没有直接方便的方案。ReplayKit Live 是目前最标准的做法，只是，使用 ReplayKit 有两个前提，应用本身支持 ReplayKit，直播平台支持 Broadcast Extension。这两个前提，后者比较容易实现，而前者，就需要靠各个应用开发商的自觉了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[更可靠和高精度的 iOS 定时器]]></title>
    <link href="http://blog.lessfun.com/blog/2016/08/05/reliable-timer-in-ios/"/>
    <updated>2016-08-05T18:23:26+08:00</updated>
    <id>http://blog.lessfun.com/blog/2016/08/05/reliable-timer-in-ios</id>
    <content type="html"><![CDATA[<p>定时器一般用于延迟一段时间执行特定的代码，必要的话按照指定的频率重复执行。iOS 中延时执行有多种方式，常用的有：</p>

<ul>
<li>NSTimer</li>
<li>NSObject 的 <code>(void)performSelector:(SEL)aSelector withObject:(id)anArgument afterDelay:(NSTimeInterval)delay;</code></li>
<li>CADisplayLink</li>
<li>GCD 的 <code>dispatch_after</code></li>
<li>GCD 的 <code>dispatch_source_t</code></li>
</ul>


<p>每种方法创建的定时器，其可靠性与最小精度都有不同。<code>可靠性</code>指是否严格按照设定的时间间隔按时执行，<code>最小精度</code>指支持的最小时间间隔是多少。</p>

<!--more-->


<h2>1. NSRunLoop</h2>

<p>谈到定时器，首先需要了解的一个概念是 <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSRunLoop_Class/">NSRunLoop</a>。NSRunLoop 是消息处理的一种机制，类似于 Windows 中的<a href="http://winprog.org/tutorial/message_loop.html">消息循环</a>，有个更通用的叫法是 <a href="https://en.wikipedia.org/wiki/Event_loop">Event Loop</a>。</p>

<p>其原理很简单，启动一个循环，无限地重复<code>接受消息-&gt;等待消息-&gt;处理消息</code>这个过程，直到退出。伪代码如下：</p>

<p>``` c
void loop() {</p>

<pre><code>do {
    void *msg = getMessage();
    processMessage(msg);
} while (msg != quit);
</code></pre>

<p>}
```</p>

<p>每个线程内部都会有一个 RunLoop，启动 RunLoop 之后，就能够让线程在没有消息时休眠，在有消息时被唤醒并处理消息，避免资源长期被占用。</p>

<p>在 iOS 中，NSThead 和 NSRunLoop 是一一对应的，但创建线程的时候不会默认创建 NSRunLoop，实际上也不允许自己创建 NSRunLoop，在线程内第一次调用<code>[NSRunLoop currentRunLoop]</code>的时候才会自动创建。</p>

<h3>1.1 NSRunLoop 处理的输入源(input sources)：</h3>

<ul>
<li>鼠标、键盘事件。</li>
<li>NSPort 对象。</li>
<li>NSConnection 对象。</li>
</ul>


<p>NSRunLoop 也处理 NSTimer 事件，但 NSTimer 并不属于输入源的一种。</p>

<h3>1.2 苹果使用 NSRunLoop 实现的功能：</h3>

<ul>
<li>硬件操作，如触摸、按键、摇晃等。</li>
<li>手势操作。</li>
<li>界面刷新，如更新了 UI 的 frame，或手动调 setNeedsLayout/setNeedsDisplay。</li>
<li>定时器。包括 NSTimer、CADisplayLink、PerformSelecter、GCD。</li>
<li>网络请求。</li>
</ul>


<p><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入了解 RunLoop</a>有更深入完整的介绍。</p>

<h2>2. NSTimer</h2>

<p>最常用，能满足对间隔要求不严格、对精确度不敏感的需求。</p>

<h3>2.1 使用方法</h3>

<p>``` objc</p>

<ul>
<li><p>(void)startNSTimer {
  self.timer = [NSTimer scheduledTimerWithTimeInterval:self.timeInterval target:self selector:@selector(onNSTimerTimeout:) userInfo:nil repeats:YES];
}</p></li>
<li><p>(void)onNSTimerTimeout:(id)sender {
  NSLog(@&ldquo;onNSTimerTimeout&rdquo;);
}</p></li>
</ul>


<p>```</p>

<h3>2.2 可靠性</h3>

<p>不可靠，其所在的 RunLoop 会定时检测是否可以触发 NSTimer 的事件，但由于 iOS 有多个 RunLoop 的运行模式，如果被切到另一个 run loop，NSTimer 就不会被触发。每个 RunLoop 的循环间隔也无法保证，当某个任务耗时比较久，RunLoop 的下一个消息处理就只能顺延，导致 NSTimer 的时间已经到达，但 Runloop 却无法及时触发 NSTimer，导致该时间点的回调被错过。</p>

<p>苹果官方文档：</p>

<blockquote><p>A timer is not a real-time mechanism; it fires only when one of the run loop modes to which the timer has been added is running and able to check if the timer’s firing time has passed.
If a timer’s firing time occurs during a long callout or while the run loop is in a mode that is not monitoring the timer, the timer does not fire until the next time the run loop checks the timer.</p></blockquote>

<h3>2.3 最小精度</h3>

<p>理论上最小精度为 0.1 毫秒。不过由于受 Runloop 的影响，会有 50 ~ 100 毫秒的误差，所以，实际精度可以认为是 0.1 秒。</p>

<p>苹果官方文档：</p>

<blockquote><p>Because of the various input sources a typical run loop manages, the effective resolution of the time interval for a timer is limited to on the order of 50-100 milliseconds.</p></blockquote>

<h3>2.4 实测结果</h3>

<p>间隔 0.1 秒，调用12次。其中倒数第二次调用前会执行一个比较耗时的运算任务。</p>

<p>代码：</p>

<p>``` objc
&ndash; (void)startNSTimer {</p>

<pre><code>[self setupConfig];

[self runNSTimerIfNeeded];

NSLog(@"NSTimer start with interval: %.3f ms, start time: %@, total count: %d", self.timeInterval * 1000, [self timeStringWithTime:self.startTime], (int)self.maxCount);
</code></pre>

<p>}</p>

<ul>
<li><p>(void)runNSTimerIfNeeded {
  self.timer = [NSTimer scheduledTimerWithTimeInterval:self.timeInterval
                                   target:self
                                 selector:@selector(onNSTimerTimeout:)
                                 userInfo:nil
                                  repeats:NO];</p>

<p>  self.startTime = [NSDate date];
}</p></li>
<li><p>(void)onNSTimerTimeout:(NSTimer *)sender {
  NSLog(@&ldquo;%d, %@&rdquo;, ++ self.curCount, [self diffTimeStringFromStart]);</p>

<p>  [self.timer invalidate];
  self.timer = nil;</p>

<p>  if (self.curCount &lt; self.maxCount) {
      [self runNSTimerIfNeeded];
      [self runBusyTaskIfNeeded];
  }
}
```</p></li>
</ul>


<p>结果：</p>

<p><code>sh
2016-08-29 11:32:40.302 TimerDemo[37258:10736148] NSTimer start with interval: 100.000 ms, start time: 1472441560302.602 ms, total count: 12
2016-08-29 11:32:40.403 TimerDemo[37258:10736148] 1, interval: 101.045 ms, discrepancy: 1.045 ms
2016-08-29 11:32:40.505 TimerDemo[37258:10736148] 2, interval: 100.890 ms, discrepancy: 0.890 ms
2016-08-29 11:32:40.606 TimerDemo[37258:10736148] 3, interval: 101.087 ms, discrepancy: 1.087 ms
2016-08-29 11:32:40.707 TimerDemo[37258:10736148] 4, interval: 101.038 ms, discrepancy: 1.038 ms
2016-08-29 11:32:40.809 TimerDemo[37258:10736148] 5, interval: 101.061 ms, discrepancy: 1.061 ms
2016-08-29 11:32:40.910 TimerDemo[37258:10736148] 6, interval: 101.069 ms, discrepancy: 1.069 ms
2016-08-29 11:32:41.012 TimerDemo[37258:10736148] 7, interval: 101.031 ms, discrepancy: 1.031 ms
2016-08-29 11:32:41.113 TimerDemo[37258:10736148] 8, interval: 101.035 ms, discrepancy: 1.035 ms
2016-08-29 11:32:41.214 TimerDemo[37258:10736148] 9, interval: 100.890 ms, discrepancy: 0.890 ms
2016-08-29 11:32:41.315 TimerDemo[37258:10736148] 10, interval: 101.042 ms, discrepancy: 1.042 ms
2016-08-29 11:32:41.315 TimerDemo[37258:10736148] start busy task
2016-08-29 11:32:41.970 TimerDemo[37258:10736148] finish busy task
2016-08-29 11:32:41.970 TimerDemo[37258:10736148] 11, interval: 654.319 ms, discrepancy: 554.319 ms
2016-08-29 11:32:42.071 TimerDemo[37258:10736148] 12, interval: 100.906 ms, discrepancy: 0.906 ms
</code></p>

<p>可以看到偏差在 1 ~ 2 毫秒左右。在第 10 次之后执行了一个较耗时的任务，导致第 11 次比预期延迟了 0.5 秒执行。后面的回调仍然按照预设的延时执行。</p>

<h2>3. performSelector:withObject:afterDelay:</h2>

<p>这是 NSObject 对 NSTimer 封装后提供的一个比较简单的延时方法，内部用的也是 NSTimer，所以，同上。</p>

<h2>4. CADisplayLink</h2>

<p>CADisplayLink 也可以用作定时器，其调用间隔与屏幕刷新频率一致，也就是每秒 60 帧，间隔 16.67 ms。与 NSTimer 类似，如果在两次屏幕刷新之间执行了一个比较耗时的任务，其中的某一帧就会被跳过，造成 UI 卡顿。</p>

<h3>4.1 使用方法</h3>

<p>``` objc</p>

<ul>
<li><p>(void)runCADisplayLinkTimer {
  CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(onCADisplayLinkTimeout)];
  displayLink.frameInterval = 0.0167; // S
  [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
  self.displayLink = displayLink;
}</p></li>
<li><p>(void)onCADisplayLinkTimeout {
  NSLog(@&ldquo;onCADisplayLinkTimeout&rdquo;);
}
```</p></li>
</ul>


<h3>4.2 可靠性</h3>

<p>如果执行的任务很耗时，也会导致回调被错过，所以并不十分可靠。但是，假如调用者能够确保任务能够在最小时间间隔内执行完成，CADisplayLink 就比较可靠，因为屏幕的刷新频率是固定的。</p>

<h3>4.3 最小精度</h3>

<p>受限于每秒 60 帧的屏幕刷新频率，注定 CADisplayLink 的最小精度为 16.67 毫秒。误差在 1 毫秒左右。</p>

<p>另外需要注意的是，虽然 CADisplayLink 有一个属性 <code>frameInterval</code> 是用于设置定时器的调用间隔，但是这个属性会在第一次回调之后才生效，对于第一次回调，总是会以 1/60 的间隔来执行的。这样会导致的结果是，比如你设置了每 1 秒执行一次某个方法，但是第一次执行的时候，却是在 16.7 毫秒之后，远远小于预设值。</p>

<h3>4.4 实测结果</h3>

<p>间隔 0.1 秒，调用12次。其中倒数第二次调用前会执行一个比较耗时的运算任务。</p>

<p>代码：</p>

<p>``` objc
&ndash; (void)startCADisplayLinkTimer {</p>

<pre><code>[self setupConfig];

[self runCADisplayLinkTimer];

NSLog(@"CADisplayLink start with interval: %.3f ms, start time: %@, total count: %d", self.timeInterval * 1000, [self timeStringWithTime:self.startTime], (int)self.maxCount);
</code></pre>

<p>}</p>

<ul>
<li><p>(void)runCADisplayLinkTimer {
  CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(onCADisplayLinkTimeout)];
  NSInteger frameInterval = floor(self.timeInterval * 1000 / (1000 / 60.0));
  displayLink.frameInterval = frameInterval;</p>

<p>  [displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSRunLoopCommonModes];
  self.displayLink = displayLink;</p>

<p>  self.startTime = [NSDate date];
}</p></li>
<li><p>(void)onCADisplayLinkTimeout {
  NSLog(@&ldquo;%d, %@&rdquo;, ++ self.curCount, [self diffTimeStringFromStart]);</p>

<p>  if (self.curCount &lt; self.maxCount) {
      self.startTime = [NSDate date];
      [self runBusyTaskIfNeeded];
  } else {
      [self.displayLink invalidate];
      self.displayLink = nil;
  }
}
```</p></li>
</ul>


<p>结果：</p>

<p><code>sh
2016-08-29 11:33:47.835 TimerDemo[37258:10736148] CADisplayLink start with interval: 100.000 ms, start time: 1472441627835.872 ms, total count: 12
2016-08-29 11:33:47.845 TimerDemo[37258:10736148] 1, interval: 10.061 ms, discrepancy: -89.939 ms
2016-08-29 11:33:47.946 TimerDemo[37258:10736148] 2, interval: 99.829 ms, discrepancy: -0.171 ms
2016-08-29 11:33:48.046 TimerDemo[37258:10736148] 3, interval: 99.573 ms, discrepancy: -0.427 ms
2016-08-29 11:33:48.145 TimerDemo[37258:10736148] 4, interval: 99.427 ms, discrepancy: -0.573 ms
2016-08-29 11:33:48.246 TimerDemo[37258:10736148] 5, interval: 99.801 ms, discrepancy: -0.199 ms
2016-08-29 11:33:48.346 TimerDemo[37258:10736148] 6, interval: 99.754 ms, discrepancy: -0.246 ms
2016-08-29 11:33:48.446 TimerDemo[37258:10736148] 7, interval: 99.791 ms, discrepancy: -0.209 ms
2016-08-29 11:33:48.546 TimerDemo[37258:10736148] 8, interval: 99.836 ms, discrepancy: -0.164 ms
2016-08-29 11:33:48.646 TimerDemo[37258:10736148] 9, interval: 99.840 ms, discrepancy: -0.160 ms
2016-08-29 11:33:48.746 TimerDemo[37258:10736148] 10, interval: 99.811 ms, discrepancy: -0.189 ms
2016-08-29 11:33:48.746 TimerDemo[37258:10736148] start busy task
2016-08-29 11:33:49.399 TimerDemo[37258:10736148] finish busy task
2016-08-29 11:33:49.400 TimerDemo[37258:10736148] 11, interval: 653.891 ms, discrepancy: 553.891 ms
2016-08-29 11:33:49.412 TimerDemo[37258:10736148] 12, interval: 12.566 ms, discrepancy: -87.434 ms
</code></p>

<p>除了第一次回调，间隔误差比较大之外，别的回调误差在 0.1 ~ 0.5 毫秒之间，精度比 NSTimer 要高。第 11 次回调，受耗时任务影响，延时了 0.5 秒。值得注意的是，第 12 次，延时再次与第一次回调一样，变成了 1/60 秒左右。</p>

<p>换言之，CADisplayLink 在第一次回调以及在耗时任务之后的回调，精度不可控。</p>

<h2>5. GCD <code>dispatch_after</code></h2>

<p>dispatch_after 用起来十分简单，代码紧凑易读，而且可以很轻松地在别的线程分配延时任务，所以使用范围很广泛。</p>

<h3>5.1 使用方法</h3>

<p>``` objc</p>

<pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(timeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
    //handle timeout
});
</code></pre>

<p>```</p>

<h3>5.2 可靠性</h3>

<blockquote><p>Any fire of the timer may be delayed by the system in order to improve power consumption and system performance. The upper limit to the allowable delay may be configured with the &lsquo;leeway&rsquo; argument, the lower limit is under the control of the system.</p></blockquote>

<h3>5.3 最小精度</h3>

<p>延时参数的单位是纳秒。如果有延时，则无法保证。</p>

<h3>5.4 实测结果</h3>

<p>间隔 0.1 秒，调用12次。其中倒数第二次调用前会执行一个比较耗时的运算任务。</p>

<p>代码：</p>

<p>``` objc
&ndash; (void)startDispatchAfterTimer {</p>

<pre><code>[self setupConfig];

[self runDispatchAfterTimerIfNeeded];

NSLog(@"DispatchAfterTimer start with interval: %.3f ms, start time: %@, total count: %d", self.timeInterval * 1000, [self timeStringWithTime:self.startTime], (int)self.maxCount);
</code></pre>

<p>}</p>

<ul>
<li><p>(void)runDispatchAfterTimerIfNeeded {
  dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(self.timeInterval * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
      [self onDispatchAfterTimeout];
  });</p>

<p>  self.startTime = [NSDate date];
}</p></li>
<li><p>(void)onDispatchAfterTimeout {
  NSLog(@&ldquo;%d, %@&rdquo;, ++ self.curCount, [self diffTimeStringFromStart]);
  if (self.curCount &lt; self.maxCount) {
      [self runDispatchAfterTimerIfNeeded];
      [self runBusyTaskIfNeeded];
  }
}
```</p></li>
</ul>


<p>结果：</p>

<p><code>sh
2016-08-29 11:34:09.652 TimerDemo[37258:10736148] DispatchAfterTimer start with interval: 100.000 ms, start time: 1472441649652.825 ms, total count: 12
2016-08-29 11:34:09.756 TimerDemo[37258:10736148] 1, interval: 103.876 ms, discrepancy: 3.876 ms
2016-08-29 11:34:09.866 TimerDemo[37258:10736148] 2, interval: 109.686 ms, discrepancy: 9.686 ms
2016-08-29 11:34:09.976 TimerDemo[37258:10736148] 3, interval: 109.772 ms, discrepancy: 9.772 ms
2016-08-29 11:34:10.085 TimerDemo[37258:10736148] 4, interval: 108.764 ms, discrepancy: 8.764 ms
2016-08-29 11:34:10.195 TimerDemo[37258:10736148] 5, interval: 109.057 ms, discrepancy: 9.057 ms
2016-08-29 11:34:10.299 TimerDemo[37258:10736148] 6, interval: 104.544 ms, discrepancy: 4.544 ms
2016-08-29 11:34:10.408 TimerDemo[37258:10736148] 7, interval: 108.753 ms, discrepancy: 8.753 ms
2016-08-29 11:34:10.516 TimerDemo[37258:10736148] 8, interval: 107.597 ms, discrepancy: 7.597 ms
2016-08-29 11:34:10.626 TimerDemo[37258:10736148] 9, interval: 109.933 ms, discrepancy: 9.933 ms
2016-08-29 11:34:10.736 TimerDemo[37258:10736148] 10, interval: 109.791 ms, discrepancy: 9.791 ms
2016-08-29 11:34:10.736 TimerDemo[37258:10736148] start busy task
2016-08-29 11:34:11.394 TimerDemo[37258:10736148] finish busy task
2016-08-29 11:34:11.394 TimerDemo[37258:10736148] 11, interval: 657.669 ms, discrepancy: 557.669 ms
2016-08-29 11:34:11.496 TimerDemo[37258:10736148] 12, interval: 102.005 ms, discrepancy: 2.005 ms
</code></p>

<p>平均误差 9 毫秒。</p>

<h2>6. GCD <code>dispatch_source_t</code></h2>

<p>经测试，dispatch_source_t 的最小精度和可靠性都与 diapatch_after 差不多。</p>

<h3>6.1 实测结果</h3>

<p>间隔 0.1 秒，调用12次。其中倒数第二次调用前会执行一个比较耗时的运算任务。</p>

<p>代码：</p>

<p>``` objc
&ndash; (void)startDispatchSourceTimer {</p>

<pre><code>[self setupConfig];

[self runDispatchSourceTimerIfNeeded];

NSLog(@"DispatchSourceTimer start with interval: %.3f ms, start time: %@, total count: %d", self.timeInterval * 1000, [self timeStringWithTime:self.startTime], (int)self.maxCount);
</code></pre>

<p>}</p>

<ul>
<li><p>(void)runDispatchSourceTimerIfNeeded {
  self.sourceTimer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());</p>

<p>  dispatch_time_t start = dispatch_time(DISPATCH_TIME_NOW, 0);
  dispatch_source_set_timer(self.sourceTimer, start, (int64_t)(self.timeInterval * NSEC_PER_SEC), 0);</p>

<p>  dispatch_source_set_event_handler(self.sourceTimer, ^{
      [self onDispatchSourceTimeout];
  });</p>

<p>  dispatch_resume(self.sourceTimer);</p>

<p>  self.startTime = [NSDate date];
}</p></li>
<li><p>(void)onDispatchSourceTimeout {
  NSLog(@&ldquo;%d, %@&rdquo;, ++ self.curCount, [self diffTimeStringFromStart]);</p>

<p>  dispatch_cancel(self.sourceTimer);
  self.timer = nil;</p>

<p>  if (self.curCount &lt; self.maxCount) {
      [self runDispatchAfterTimerIfNeeded];
      [self runBusyTaskIfNeeded];
  }
}
```</p></li>
</ul>


<p>结果：</p>

<p><code>sh
2016-08-29 11:34:24.088 TimerDemo[37258:10736148] DispatchSourceTimer start with interval: 100.000 ms, start time: 1472441664088.390 ms, total count: 12
2016-08-29 11:34:24.089 TimerDemo[37258:10736148] 1, interval: 1.429 ms, discrepancy: -98.571 ms
2016-08-29 11:34:24.196 TimerDemo[37258:10736148] 2, interval: 106.696 ms, discrepancy: 6.696 ms
2016-08-29 11:34:24.306 TimerDemo[37258:10736148] 3, interval: 109.500 ms, discrepancy: 9.500 ms
2016-08-29 11:34:24.416 TimerDemo[37258:10736148] 4, interval: 109.999 ms, discrepancy: 9.999 ms
2016-08-29 11:34:24.526 TimerDemo[37258:10736148] 5, interval: 109.744 ms, discrepancy: 9.744 ms
2016-08-29 11:34:24.636 TimerDemo[37258:10736148] 6, interval: 109.691 ms, discrepancy: 9.691 ms
2016-08-29 11:34:24.746 TimerDemo[37258:10736148] 7, interval: 109.767 ms, discrepancy: 9.767 ms
2016-08-29 11:34:24.856 TimerDemo[37258:10736148] 8, interval: 109.799 ms, discrepancy: 9.799 ms
2016-08-29 11:34:24.966 TimerDemo[37258:10736148] 9, interval: 109.820 ms, discrepancy: 9.820 ms
2016-08-29 11:34:25.076 TimerDemo[37258:10736148] 10, interval: 109.804 ms, discrepancy: 9.804 ms
2016-08-29 11:34:25.076 TimerDemo[37258:10736148] start busy task
2016-08-29 11:34:25.734 TimerDemo[37258:10736148] finish busy task
2016-08-29 11:34:25.734 TimerDemo[37258:10736148] 11, interval: 657.591 ms, discrepancy: 557.591 ms
2016-08-29 11:34:25.835 TimerDemo[37258:10736148] 12, interval: 101.295 ms, discrepancy: 1.295 ms
</code></p>

<p>从结果看，与 <code>diapatch_after</code> 区别不大。</p>

<h2>7. 更高精度的定时器</h2>

<p>上述的各种定时器，都受限于苹果为了保护电池和提高性能采用的策略，导致无法实时地执行回调。如果你的确需要使用更高精度的定时器，官方也提供了方法，见
<a href="https://developer.apple.com/library/ios/technotes/tn2169/_index.html">High Precision Timers in iOS / OS X</a></p>

<p>前面所述的定时器，使用方法各有不同，但其核心代码实际上是一样的。</p>

<blockquote><p>There are many API&rsquo;s in iOS and OS X that allow waiting for a specified period of time. They may be Objective C or C, and they take different kinds of arguments, but they all end up using the same code inside the kernel.</p></blockquote>

<p>而有别于普通定时器的<a href="https://developer.apple.com/library/ios/technotes/tn2169/_index.html#//apple_ref/doc/uid/DTS40013172-CH1-TNTAG5000">高精度定时器</a>，则是基于高优先级的线程调度类创建的定时器，在没有多线程冲突的情况下，这类定时器的请求会被优先处理。</p>

<h3>7.1 实现方法</h3>

<ul>
<li>把定时器所在的线程，移到高优先级的线程调度类。</li>
<li>使用更精确的计时器API，换言之，你想要 10 秒后执行，就绝对在 10 秒后执行，绝不提前，也不延迟。</li>
</ul>


<h3>7.2 如何使用</h3>

<ul>
<li><a href="https://developer.apple.com/library/ios/technotes/tn2169/_index.html#//apple_ref/doc/uid/DTS40013172-CH1-TNTAG6000">How do I get put into the real time scheduling class?</a></li>
<li><a href="https://developer.apple.com/library/ios/technotes/tn2169/_index.html#//apple_ref/doc/uid/DTS40013172-CH1-TNTAG8000">Which timing API(s) should I use?</a></li>
</ul>


<p>提高调度优先级：</p>

<p>``` cpp</p>

<h1>include &lt;mach/mach.h></h1>

<h1>include &lt;mach/mach_time.h></h1>

<h1>include &lt;pthread.h></h1>

<p>void move_pthread_to_realtime_scheduling_class(pthread_t pthread) {</p>

<pre><code>mach_timebase_info_data_t timebase_info;
mach_timebase_info(&amp;timebase_info);

const uint64_t NANOS_PER_MSEC = 1000000ULL;
double clock2abs = ((double)timebase_info.denom / (double)timebase_info.numer) * NANOS_PER_MSEC;

thread_time_constraint_policy_data_t policy;
policy.period      = 0;
policy.computation = (uint32_t)(5 * clock2abs); // 5 ms of work
policy.constraint  = (uint32_t)(10 * clock2abs);
policy.preemptible = FALSE;

int kr = thread_policy_set(pthread_mach_thread_np(pthread_self()),
               THREAD_TIME_CONSTRAINT_POLICY,
               (thread_policy_t)&amp;policy,
               THREAD_TIME_CONSTRAINT_POLICY_COUNT);
if (kr != KERN_SUCCESS) {
    mach_error("thread_policy_set:", kr);
    exit(1);
}
</code></pre>

<p>}
```</p>

<p>精确延时：</p>

<p>``` cpp</p>

<h1>include &lt;mach/mach.h></h1>

<h1>include &lt;mach/mach_time.h></h1>

<p>static const uint64_t NANOS_PER_USEC = 1000ULL;
static const uint64_t NANOS_PER_MILLISEC = 1000ULL * NANOS_PER_USEC;
static const uint64_t NANOS_PER_SEC = 1000ULL * NANOS_PER_MILLISEC;</p>

<p>static mach_timebase_info_data_t timebase_info;</p>

<p>static uint64_t abs_to_nanos(uint64_t abs) {</p>

<pre><code>return abs * timebase_info.numer  / timebase_info.denom;
</code></pre>

<p>}</p>

<p>static uint64_t nanos_to_abs(uint64_t nanos) {</p>

<pre><code>return nanos * timebase_info.denom / timebase_info.numer;
</code></pre>

<p>}</p>

<p>void example_mach_wait_until(int argc, const char * argv[]) {</p>

<pre><code>mach_timebase_info(&amp;timebase_info);
uint64_t time_to_wait = nanos_to_abs(10ULL * NANOS_PER_SEC);
uint64_t now = mach_absolute_time();
mach_wait_until(now + time_to_wait);
</code></pre>

<p>}
```</p>

<h3>7.3 最小精度</h3>

<p>小于 0.5 毫秒。<a href="http://atastypixel.com/blog/wp-content/uploads/2011/09/TPPreciseTimer.zip">这里</a>有一份实现的代码以及与普通定时器的对比。</p>

<h2>8. 参考</h2>

<ul>
<li><a href="http://blog.ibireme.com/2015/05/18/runloop/">深入了解 RunLoop</a></li>
<li><a href="https://developer.apple.com/library/ios/technotes/tn2169/_index.html">High Precision Timers in iOS / OS X</a></li>
<li><a href="http://atastypixel.com/blog/experiments-with-precise-timing-in-ios/">Experiments with precise timing in iOS</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Swift语言在iOS客户端生成七牛的上传Token]]></title>
    <link href="http://blog.lessfun.com/blog/2015/12/29/swift-create-qiniu-upload-token/"/>
    <updated>2015-12-29T14:14:01+08:00</updated>
    <id>http://blog.lessfun.com/blog/2015/12/29/swift-create-qiniu-upload-token</id>
    <content type="html"><![CDATA[<p>七牛SDK官方不推荐由客户端生成Token，所以在SDK的源码以及Demo中都没有提供生成上传Token的接口与示例。但是有时候的确需要在客户端生成Token，因为个人用户哪里有那么多服务器啊……本文提供了Swift语言版本在iOS客户端生成七牛上传Token的示例代码。</p>

<!--more-->


<h2>Token 的生成算法</h2>

<p>详见 <a href="http://developer.qiniu.com/docs/v6/api/reference/security/upload-token.html">官方说明</a>。概述如下：</p>

<ol>
<li>构造<a href="http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html">上传策略</a>，转为 JSON 字符串，进行 <a href="http://developer.qiniu.com/docs/v6/api/overview/appendix.html#urlsafe-base64">URL安全的Base64编码</a>，得到 <code>encodedPutPolicy</code>。</li>
<li>使用 <code>SecretKey</code> 对上一步生成的 <code>encodedPutPolicy</code> 计算 <a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC-SHA1</a> 签名，进行URL安全的Base64编码，得到 <code>encodedSign</code>。</li>
<li>将 <code>AccessKey</code>、<code>encodedSign</code> 和 <code>encodedPutPolicy</code> 用<code>:</code>连接起来，得到Token</li>
</ol>


<h2>Swift 示例代码</h2>

<h3>修改 Podfile 文件添加七牛依赖库</h3>

<p>``` bash
source &lsquo;<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a>&rsquo;
platform :ios, &lsquo;8.0&rsquo;
use_frameworks!</p>

<p>inhibit_all_warnings!</p>

<p>pod &lsquo;JSONKit-NoWarning&rsquo;, &lsquo;1.2&rsquo;
pod &lsquo;AFNetworking&rsquo;, &lsquo;2.5.0&rsquo;
pod &lsquo;Qiniu&rsquo;, &lsquo;~> 7.0&rsquo;
```</p>

<h3>在 .swift 文件上方，引入库，定义钥匙串</h3>

<p>``` objc
import Qiniu
import JSONKit_NoWarning</p>

<p>let kQiniuBucket = &ldquo;qiniubucket&rdquo;
let kQiniuAccessKey = &ldquo;xxxxxxxxxxxxxxxxxxxxxx&mdash;xxxxxxxxxxxxxxxx&rdquo;
let kQiniuSecretKey = &ldquo;xxxxxxxxxxxxxxxxxxxxxx&mdash;xxxxxxxxxxxxxxxx&rdquo;
```</p>

<h3>定义辅助方法</h3>

<p>``` objc</p>

<pre><code>func hmacsha1WithString(str: String, secretKey: String) -&gt; NSData {

    let cKey  = secretKey.cStringUsingEncoding(NSASCIIStringEncoding)
    let cData = str.cStringUsingEncoding(NSASCIIStringEncoding)

    var result = [CUnsignedChar](count: Int(CC_SHA1_DIGEST_LENGTH), repeatedValue: 0)
    CCHmac(CCHmacAlgorithm(kCCHmacAlgSHA1), cKey!, Int(strlen(cKey!)), cData!, Int(strlen(cData!)), &amp;result)
    let hmacData: NSData = NSData(bytes: result, length: (Int(CC_SHA1_DIGEST_LENGTH)))
    return hmacData
}
</code></pre>

<p>```</p>

<p>其中，<code>CCHmac</code> 使用的是 Objective C 的 <code>#import &lt;CommonCrypto/CommonCrypto.h&gt;</code>，在 Swift 中用需要自己添加桥接头文件。</p>

<h3>定义生成 Token 方法</h3>

<p>``` objc</p>

<pre><code>func createQiniuToken(fileName: String) -&gt; String {

    let oneHourLater = NSDate().timeIntervalSince1970 + 3600
    // 上传策略中，只有scope和deadline是必填的
    let scope = fileName.isEmpty ? kQiniuBucket : kQiniuBucket + ":" + fileName;
    let putPolicy: NSDictionary = ["scope": scope, "deadline": NSNumber(unsignedLongLong: UInt64(oneHourLater))]
    let encodedPutPolicy = QNUrlSafeBase64.encodeString(putPolicy.JSONString())
    let sign = self.hmacsha1WithString(encodedPutPolicy, secretKey: kQiniuSecretKey)
    let encodedSign = QNUrlSafeBase64.encodeData(sign)

    return kQiniuAccessKey + ":" + encodedSign + ":" + encodedPutPolicy
}
</code></pre>

<p>```</p>

<h3>上传示例</h3>

<p>``` objc</p>

<pre><code>func uploadWithName(fileName: String, content: String) {
    let dict: NSDictionary = ["content": content]
    // 如果覆盖已有的文件，则指定文件名。否则如果同名文件已存在，会上传失败
    let token = self.qiniuToken(self.replaceIfExists ? fileName : "")

    var uploader: QNUploadManager = QNUploadManager()
    uploader.putData(dict.JSONData(), key: fileName, token: token, complete: { (info: QNResponseInfo!, key: String!, resp: [NSObject : AnyObject]!) -&gt; Void in
            if info.ok {
                NSLog("Success")
            } else {
                NSLog("Error: " + info.error.description)
            }
        }, option: nil)
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[非越狱 iOS 在后台截屏、录制屏幕的相关实现]]></title>
    <link href="http://blog.lessfun.com/blog/2015/12/25/ios-record-screen-in-background/"/>
    <updated>2015-12-25T16:54:31+08:00</updated>
    <id>http://blog.lessfun.com/blog/2015/12/25/ios-record-screen-in-background</id>
    <content type="html"><![CDATA[<h2>需求</h2>

<p>先简单介绍一下标题的含义。也许你看到<code>iOS</code>、<code>截屏</code>，觉得这有什么好长篇大论的，小菜一碟而已。可能你忽略了<code>后台</code>这个关键词。</p>

<p>这里的关键就在于怎么在 App 切换到后台之后，仍然能够持续截取用户屏幕内容。解决了这点，剩下的就是把图片合成视频，有必要的话再加入声音。</p>

<p>另外，需要说明的是，实现后台截屏只能使用私有 API，而苹果是不允许这类 App 上架的，就算你用了一些技巧（比如动态加载私有 API 以绕过 App Store 的审核）而上架，假以时日苹果也会发现并且下架处理。<a href="http://stackoverflow.com/questions/11090184/how-does-the-ios-app-display-recorder-record-the-screen-without-using-private-ap">Display Recorder</a> 就是这么做并且被下架的，所以现在它发到越狱市场了。</p>

<h2>作用</h2>

<p>在 iOS 上录制全局屏幕，保存成一个视频，这么一个小众需求到底有什么作用？虽然一般用户都不会用到，不过它还是有点用的：</p>

<ul>
<li>录制 App 使用的视频教程（而不是图片+文字、图片+文字、图片+文字）；</li>
<li>如果 App 有个在某些用户机器上必现的 Bug，可以让他把操作记录下来，发给开发者（这样码农们就没办法再推脱：“在我这里是好的！肯定是你的打开方式不对！”）；</li>
<li>如果你是游戏大神，玩得一手好手游，还可以把你在游戏中的神操作保存下来供日后回味（或者分享出去让小白们膜拜）。</li>
</ul>


<!--more-->


<h2>实现</h2>

<p>iOS 的系统封闭，API 变化无常，所以并没有一个可以全版本 iOS 系统通用的后台截屏方法。下面所列的方法都因系统版本而异，前提都是非越狱。</p>

<h3>1. _UICreateScreenUIImage (&lt; iOS 6)</h3>

<p><a href="http://iphonedevwiki.net/index.php/UIImage#UICreateScreenUIImage">_UICreateScreenUIImage</a> 是 UIImage 的一个私有方法，在<strong> iOS 6</strong>以前可以用于后台调用截屏，方法如下：</p>

<p>``` objc
OBJC_EXTERN UIImage *_UICreateScreenUIImage(void);</p>

<ul>
<li>(void)takeScreenshot {
  UIImage *screenImage = _UICreateScreenUIImage();
  // &hellip;
}
```</li>
</ul>


<p>但是，在 iOS 6 以后，这个方法不允许在 App 切到后台的时候调用了，会在调试控制台输出不能调用的错误提示。</p>

<h3>2. CARenderServerRenderDisplay (&lt; iOS 7)</h3>

<p><a href="https://github.com/coolstar/RecordMyScreen">RecordMyScreen</a> 用的就是这个方法，不过实测在 iOS 7以上，只能截到黑色的空白图片。网上说 RecordMyScreen 就是 Display Recorder 的开源版本。</p>

<p>其中涉及到后台截屏的代码如下：</p>

<p>``` objc</p>

<pre><code>IOSurfaceLock(_surface, 0, nil);
// Take currently displayed image from the LCD
CARenderServerRenderDisplay(0, CFSTR("LCD"), _surface, 0, 0);
// Unlock the surface
IOSurfaceUnlock(_surface, 0, 0);

// Make a raw memory copy of the surface
void *baseAddr = IOSurfaceGetBaseAddress(_surface);
int totalBytes = _bytesPerRow * _height;
NSMutableData *rawDataObj = [NSMutableData dataWithBytes:baseAddr length:totalBytes];
// ...
</code></pre>

<p>```</p>

<p>但是，经过测试，在iOS 7和iOS 8上，这个方法没办法正确截屏，只能得到黑色的图片。而且，虽说 RecordMyScreen 是一个开源项目，但实际上它并不是一份完整可用的代码，开源到中途，作者发现有人在窃取他的项目源码，于是停止了开源。虽然如此，该项目中对于音视频的编码、合成部分的处理都是很值得参考的。</p>

<h3>3. createScreenIOSurface(&lt; iOS 7?)</h3>

<p><a href="https://github.com/kishikawakatsumi/ScreenRecorder">ScreenRecorder</a> 用了这个方法，但是实际上这个项目没办法在后台运行。</p>

<p>``` objc</p>

<p>@interface UIWindow (ScreenRecorder)
+ (CFTypeRef)createScreenIOSurface;
@end</p>

<ul>
<li><p>(void)screenShot {
  CFTypeRef surface = [UIWindow createScreenIOSurface];
  backingData = surface;</p>

<p>  NSDictionary <em>pixelBufferAttributes = @{(NSString </em>)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA)};
  status = CVPixelBufferCreateWithIOSurface(NULL, surface, (__bridge CFDictionaryRef)(pixelBufferAttributes), &amp;buffer);
  // &hellip;
}
```</p></li>
</ul>


<h3>4. 终极方法 IOSurface (&lt; iOS 9)</h3>

<p>好吧，前面提到的几种方法在 iOS 7 以上版本都没啥卵用。现在说的这个方法是可以在 iOS 7 和 iOS 8 上使用的，只是 iOS 9 禁用了该方法。</p>

<p>与 RecordMyScreen 类似，还是基于 IOSurface 私有库，只是调用的方法不太一样：</p>

<p>``` objc
&ndash; (UIImage *)screenshot() {</p>

<pre><code>IOMobileFramebufferConnection connect;
kern_return_t result;
</code></pre>

<p>CoreSurfaceBufferRef screenSurface = NULL;</p>

<pre><code>io_service_t framebufferService = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("AppleH1CLCD"));
</code></pre>

<p>if(!framebufferService)</p>

<pre><code>    framebufferService = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("AppleM2CLCD"));
</code></pre>

<p>if(!framebufferService)</p>

<pre><code>    framebufferService = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("AppleCLCD"));
</code></pre>

<p>result = IOMobileFramebufferOpen(framebufferService, mach_task_self(), 0, &amp;connect);
result = IOMobileFramebufferGetLayerDefaultSurface(connect, 0, &amp;screenSurface);</p>

<pre><code>uint32_t aseed;
IOSurfaceLock((IOSurfaceRef)screenSurface, 0x00000001, &amp;aseed);
size_t width = IOSurfaceGetWidth((IOSurfaceRef)screenSurface);

size_t height = IOSurfaceGetHeight((IOSurfaceRef)screenSurface);
CFMutableDictionaryRef dict;
</code></pre>

<p>size_t pitch = width<em>4, size = width</em>height*4;</p>

<pre><code>int bPE=4;

char pixelFormat[4] = {'A','R','G','B'};
dict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);
CFDictionarySetValue(dict, kIOSurfaceIsGlobal, kCFBooleanTrue);
CFDictionarySetValue(dict, kIOSurfaceBytesPerRow, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;pitch));
CFDictionarySetValue(dict, kIOSurfaceBytesPerElement, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;bPE));
CFDictionarySetValue(dict, kIOSurfaceWidth, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;width));
CFDictionarySetValue(dict, kIOSurfaceHeight, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;height));
CFDictionarySetValue(dict, kIOSurfacePixelFormat, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, pixelFormat));
CFDictionarySetValue(dict, kIOSurfaceAllocSize, CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &amp;size));

IOSurfaceRef destSurf = IOSurfaceCreate(dict);
IOSurfaceAcceleratorRef outAcc;
IOSurfaceAcceleratorCreate(NULL, 0, &amp;outAcc);

IOSurfaceAcceleratorTransferSurface(outAcc, (IOSurfaceRef)screenSurface, destSurf, dict, NULL);
IOSurfaceUnlock((IOSurfaceRef)screenSurface, kIOSurfaceLockReadOnly, &amp;aseed);
</code></pre>

<p>CFRelease(outAcc);</p>

<pre><code>CGDataProviderRef provider =  CGDataProviderCreateWithData(NULL,  IOSurfaceGetBaseAddress(destSurf), (width * height * 4), NULL);

CGImageRef cgImage = CGImageCreate(width, height, 8,
</code></pre>

<p>8*4, IOSurfaceGetBytesPerRow(destSurf),
 CGColorSpaceCreateDeviceRGB(), kCGImageAlphaNoneSkipFirst |kCGBitmapByteOrder32Little, provider, NULL, YES, kCGRenderingIntentDefault);</p>

<pre><code>UIImage *image = [UIImage imageWithCGImage:cgImage];
return image;
</code></pre>

<p>}
```</p>

<p>见：</p>

<ul>
<li><a href="http://stackoverflow.com/questions/21870667/iomobileframebuffergetlayerdefaultsurface-does-not-work-on-ios7-retina">IOMobileFramebufferGetLayerDefaultSurface does not work on ios7 retina</a></li>
<li><a href="http://stackoverflow.com/questions/32239969/iomobileframebuffergetlayerdefaultsurface-not-working-on-ios-9">IOMobileFramebufferGetLayerDefaultSurface not working on iOS 9</a></li>
</ul>


<h2>合成</h2>

<p>在 App 后台得到截图之后怎么处理成视频呢？其实在 RecordMyScreen 中有完整的代码可以参考，只是它里面截屏的方法需要替换为本文提到的<code>第四种</code>实现，不赘述。</p>

<h2>注意</h2>

<ol>
<li>需要修改 App 的 plist 文件，使其能在后台运行。</li>
<li>需要打开设备的 Access Touch 功能，否则对于 OpenGL 实现的游戏 App，会黑屏。</li>
<li>iPad Retina 屏幕像素过大，处理起来很吃力，需要减小生成的图片大小。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIViewController Push & Pop 的那些坑]]></title>
    <link href="http://blog.lessfun.com/blog/2015/09/09/uiviewcontroller-push-pop-trap/"/>
    <updated>2015-09-09T18:37:32+08:00</updated>
    <id>http://blog.lessfun.com/blog/2015/09/09/uiviewcontroller-push-pop-trap</id>
    <content type="html"><![CDATA[<p>iOS开发中，UIViewController是最常用的一个类，在Push和Pop的过程中也会经常出现一些UI卡死、App闪退的问题，本文总结了开发中遇到的一些坑。</p>

<p>大部分视图控制器切换导致的问题，根本原因都是使用了动画，因为执行动画需要时间，在动画未完成的时候又进行另一个切换动画，容易产生异常，假如在 Push 和 Pop 的过程不使用动画，世界会清静很多。所以本文只讨论使用了动画的视图切换。也就是使用以下方式的 Push 和 Pop：</p>

<p>``` objc</p>

<pre><code>[self.navigationController pushViewController:controller animated:YES];
[self.navigationController popViewControllerAnimated:YES];
</code></pre>

<p>```</p>

<!--more-->


<h2>1. 连续 Push</h2>

<p>连续两次 Push 不同的 ViewController 是没问题的，比如这样：</p>

<p>``` objc
&ndash; (void)onPush: {</p>

<pre><code>[self.navigationController pushViewController:vc1 animated:YES];
[self.navigationController pushViewController:vc2 animated:YES];
</code></pre>

<p>}
```</p>

<p>但是，如果不小心连续 Push 了同一个 ViewController，并且 animated 为 YES，则会 Crash：<code>Pushing the same view controller instance more than once is not supported</code>。</p>

<p>这种情况很有可能发生，特别是界面上触发切换的入口不止一处，并且各个入口的点击没有互斥的话，用两根手指同时点击屏幕就会同时触发两个入口的切换了。多点触碰导致的同时 Push，基本上是防不胜防，当界面元素很复杂的时候，特别容易出现这个问题，而指望从用户交互的角度上避免这个问题是不可能的，测试美眉以暴力测试、胡乱点击而著称，防得了用户防不住测试。</p>

<p>所以我们需要从根本上解决这个问题：当一个 Push 动画还没完成的时候，不允许再 Push 别的 ViewController。这样处理是没有问题的，因为连续带动画地 Push 多个 ViewController 肯定不是开发和产品的意愿，就算有这种需求，也可以通过禁用动画的方式来解决。</p>

<h3>1.1 解决方案</h3>

<p>继承 UINavigationController 并重载 pushViewController 方法。</p>

<ol>
<li>如果是动画 Push，并且属性 <code>isSwitching == YES</code>，则忽略这次 Push。</li>
<li>否则，设置 <code>isSwitching = YES</code> 再继续切换。</li>
<li>等到动画切换完毕，需要再把 <code>isSwitching</code> 改为 NO。</li>
</ol>


<p>``` objc</p>

<p>@interface MYNavigationController () &lt;UINavigationControllerDelegate, UIGestureRecognizerDelegate></p>

<p>@property (assign, nonatomic) BOOL isSwitching;</p>

<p>@end</p>

<p>@implementation MYNavigationController</p>

<p>// 重载 push 方法
&ndash; (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated {</p>

<pre><code>if (animated) {
    if (self.isSwitching) {
        return; // 1. 如果是动画，并且正在切换，直接忽略
    }
   self.isSwitching = YES; // 2. 否则修改状态
}

[super pushViewController:viewController animated:animated];
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; UINavigationControllerDelegate</h1>

<ul>
<li>(void)navigationController:(UINavigationController <em>)navigationController didShowViewController:(UIViewController </em>)viewController animated:(BOOL)animated {
  self.isSwitching = NO; // 3. 还原状态
}</li>
</ul>


<p>```</p>

<h2>2. 连续 Pop</h2>

<p>连续 Pop ，可能会导致两种情况。</p>

<h3>2.1 self 被释放</h3>

<p>例如，下面的代码，执行到第二句的时候，self 已经被释放了。</p>

<p>``` objc</p>

<pre><code>[self.navigationController popViewControllerAnimated:YES]; // self 被 release
[self.navigationController popViewControllerAnimated:YES]; // 继续访问 self 导致异常
</code></pre>

<p>```</p>

<h3>2.2 界面异常、崩溃</h3>

<p>假如你避开了上面那种调用，换成了这样：</p>

<p>``` objc</p>

<pre><code>[[AppDelegate sharedObject].navigationController popViewControllerAnimated:YES]; 
[[AppDelegate sharedObject].navigationController popViewControllerAnimated:YES]; 
</code></pre>

<p>```</p>

<p>由于访问的是全局的 AppDelegate，自然避免了调用者被释放的问题，但是，连续两次动画 Pop，在iOS 7.X 系统会导致界面混乱、卡死、莫名其妙的崩溃（iOS 8 貌似不存在类似的问题）。比如，下面这个崩溃的堆栈：</p>

<p>```
{&ldquo;bundleID&rdquo;:&ldquo;com.enterprise.kiwi&rdquo;,&ldquo;app_name&rdquo;:&ldquo;kiwi&rdquo;,&ldquo;bug_type&rdquo;:&ldquo;109&rdquo;,&ldquo;name&rdquo;:&ldquo;kiwi&rdquo;,&ldquo;os_version&rdquo;:&ldquo;iPhone OS 7.1.1 (11D201)&rdquo;,&ldquo;version&rdquo;:&ldquo;1190 (3.1.0)&rdquo;}
Incident Identifier: FE85E864-393C-417D-9EA0-B4324BEEDA2F
CrashReporter Key:   a54805586b9487c324ff5f42f4ac93dabbe9f23e
Hardware Model:      iPhone6,1
Process:             kiwi [1074]
Path:                /var/mobile/Applications/D81CE836-3F88-481C-AA5A-21DA530234E0/kiwi.app/kiwi
Identifier:          com.yy.enterprise.kiwi
Version:             1190 (3.1.0)
Code Type:           ARM-64 (Native)
Parent Process:      launchd [1]</p>

<p>Date/Time:           2015-09-08 15:44:57.327 +0800
OS Version:          iOS 7.1.1 (11D201)
Report Version:      104</p>

<p>Exception Type:  EXC_CRASH (SIGSEGV)
Exception Codes: 0x0000000000000000, 0x0000000000000000
Triggered by Thread:  1</p>

<p>Thread 0:
0   libobjc.A.dylib                 0x00000001993781dc objc_msgSend + 28
1   UIKit                           0x000000018feacf14 &ndash;[UIResponder(Internal) <em>canBecomeFirstResponder] + 20
2   UIKit                           0x000000018feacba0 &ndash;[UIResponder becomeFirstResponder] + 240
3   UIKit                           0x000000018feacfa0 &ndash;[UIView(Hierarchy) becomeFirstResponder] + 120
4   UIKit                           0x000000018ff320f8 &ndash;[UITextField becomeFirstResponder] + 64
5   UIKit                           0x000000018ffe4800 &ndash;[UITextInteractionAssistant(UITextInteractionAssistant_Internal) setFirstResponderIfNecessary] + 208
6   UIKit                           0x000000018ffe3f84 &ndash;[UITextInteractionAssistant(UITextInteractionAssistant_Internal) oneFingerTap:] + 1792
7   UIKit                           0x000000018ffcac60 </em>UIGestureRecognizerSendActions + 212
8   UIKit                           0x000000018fe5929c &ndash;[UIGestureRecognizer <em>updateGestureWithEvent:buttonEvent:] + 376
9   UIKit                           0x000000019025803c </em><strong>UIGestureRecognizerUpdate_block_invoke + 56
10  UIKit                           0x000000018fe1a258 <em>UIGestureRecognizerRemoveObjectsFromArrayAndApplyBlocks + 284
11  UIKit                           0x000000018fe18b34 </em>UIGestureRecognizerUpdate + 208
12  UIKit                           0x000000018fe57b1c &ndash;[UIWindow <em>sendGesturesForEvent:] + 1008
13  UIKit                           0x000000018fe5722c &ndash;[UIWindow sendEvent:] + 824
14  UIKit                           0x000000018fe28b64 &ndash;[UIApplication sendEvent:] + 252
15  UIKit                           0x000000018fe26c54 </em>UIApplicationHandleEventQueue + 8496
16  CoreFoundation                  0x000000018ce1f640 </strong>CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION<strong> + 20
17  CoreFoundation                  0x000000018ce1e99c </strong>CFRunLoopDoSources0 + 252
18  CoreFoundation                  0x000000018ce1cc34 __CFRunLoopRun + 628
19  CoreFoundation                  0x000000018cd5dc1c CFRunLoopRunSpecific + 448
20  GraphicsServices                0x0000000192a45c08 GSEventRunModal + 164
21  UIKit                           0x000000018fe8efd8 UIApplicationMain + 1152
22  kiwi                            0x000000010026a2b8 main (main.mm:26)
23  libdyld.dylib                   0x000000019995ba9c start + 0</p>

<p>Thread 1 Crashed:
0   libsystem_kernel.dylib          0x0000000199a3daa8 kevent64 + 8
1   libdispatch.dylib               0x0000000199941998 _dispatch_mgr_thread + 48
```</p>

<p>从崩溃记录完全看不出原因，十分坑爹。</p>

<h3>2.3 解决方案</h3>

<ul>
<li>方案一：第一次 Pop 不使用动画。</li>
<li>方案二：统一管理 Pop 的调用，如果当前正在 Pop，则下一次 Pop 先入栈；等到 Pop 执行完再执行下一次 Pop。</li>
</ul>


<h2>3. Push 的过程中立即 Pop</h2>

<p>Push 的过程中调用 Pop，会导致界面卡死，表现为：不响应任何点击、手势操作，但是不会崩溃。这也是在 iOS7 中出现的问题，iOS 8 之后不存在。</p>

<h3>3.1 解决方案</h3>

<p>同 1.1，重载 Pop 方法：</p>

<ol>
<li>Pop 的时候先判断是否在切换中；</li>
<li>如果正在切换，则 Pop 的命令先保存到队列；</li>
<li>切换动画执行完毕，判断是否需要处理 Pop 的队列。</li>
</ol>


<p>``` objc</p>

<h1>pragma mark &ndash; UINavigationController</h1>

<ul>
<li><p>(NSArray <em>)popToViewController:(UIViewController </em>)viewController animated:(BOOL)animated {
  if (!self.isSwitching) {
      return [super popToViewController:viewController animated:animated];
  } else {
      [self enqueuePopViewController:viewController animate:animated];
      return nil;
  }
}</p></li>
<li><p>(UIViewController *)popViewControllerAnimated:(BOOL)animated {
  if (!self.isSwitching) {
      return [super popViewControllerAnimated:animated];
  } else {
      [self enqueuePopViewController:nil animate:animated];
      return nil;
  }
}</p></li>
</ul>


<h1>pragma mark &ndash; UINavigationControllerDelegate</h1>

<ul>
<li><p>(void)navigationController:(UINavigationController <em>)navigationController didShowViewController:(UIViewController </em>)viewController animated:(BOOL)animated {
  self.isSwitching = NO;</p>

<p>  // 显示完毕之后判断是否需要Pop
  if (self.popVCAnimateQueue.count) {
      PopVCInfo *info = [self.popVCAnimateQueue firstObject];
      [self.popVCAnimateQueue removeObjectAtIndex:0];
      if (info.controller) {
          [self.navigationController popToViewController:info.controller animated:info.animate];
      } else {
          [self.navigationController popViewControllerAnimated:info.animate];
      }
  }
}</p></li>
</ul>


<p>```</p>

<h2>4. Push 的过程中手势滑动返回</h2>

<p>手势滑动返回本质上调用的还是 Pop，所以，同上。</p>

<p>不过，还可以更根本地禁止用户进行这样的操作，也就是在切换过程中禁止滑动返回手势。</p>

<p>``` objc</p>

<h1>pragma mark &ndash; UINavigationController</h1>

<p>// Hijack the push method to disable the gesture
&ndash; (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated {</p>

<pre><code>self.interactivePopGestureRecognizer.enabled = NO;

[super pushViewController:viewController animated:animated];
</code></pre>

<p>}</p>

<h1>pragma mark &ndash; UINavigationControllerDelegate</h1>

<ul>
<li><p>(void)navigationController:(UINavigationController <em>)navigationController didShowViewController:(UIViewController </em>)viewController animated:(BOOL)animated {
  self.isSwitching = NO;</p>

<p>  self.interactivePopGestureRecognizer.enabled = YES;</p>

<p>  // 显示完毕之后判断是否需要Pop
  if (self.popVCAnimateQueue.count) {
      PopVCInfo *info = [self.popVCAnimateQueue firstObject];
      [self.popVCAnimateQueue removeObjectAtIndex:0];
      if (info.controller) {
          [self.navigationController popToViewController:info.controller animated:info.animate];
      } else {
          [self.navigationController popViewControllerAnimated:info.animate];
      }
  }
}</p></li>
</ul>


<p>```</p>
]]></content>
  </entry>
  
</feed>
